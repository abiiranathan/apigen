// Code generated by "apigen"; DO NOT EDIT.

package services

import (
	"github.com/abiiranathan/apigen/models"
	"gorm.io/gorm"
	"math"
)

/*
Options to pass to GORM.
Preferred order of option: Select,Group, Where, Or, Joins, Preload, Order, Limit, Offset, etc
For example:

		Select("column1, column2").
	    Where("column3 = ?", value).
	    Joins("JOIN t1 ON t1.id = t.id").
	    Order("column ASC").
	    Limit(10).
	    Offset(0).
	    Find(&results)
*/
type Option func(db *gorm.DB) *gorm.DB

/*
Where add conditions
See the docs for details on the various formats that where clauses can take. By default, where clauses chain with AND.

	Find the first user with name john
	Where("name = ?", "john")
*/
func Where(query string, args ...any) Option {
	return func(db *gorm.DB) *gorm.DB {
		db = db.Where(query, args...)
		return db
	}
}

/*
Preload preload associations with given conditions

	Preload("Orders", "state NOT IN (?)", "cancelled")
*/
func Preload(query string, args ...any) Option {
	return func(db *gorm.DB) *gorm.DB {
		db = db.Preload(query, args...)
		return db
	}
}

/*
Select specify fields that you want when querying, creating, updating

Use Select when you only want a subset of the fields.
By default, GORM will select all fields.

	Select("name", "age")
*/
func Select(columns ...string) Option {
	return func(db *gorm.DB) *gorm.DB {
		db = db.Select(columns)
		return db
	}
}

// Omit specify fields that you want to ignore when creating, updating and querying
func Omit(columns ...string) Option {
	return func(db *gorm.DB) *gorm.DB {
		db = db.Omit(columns...)
		return db
	}
}

// Order("name DESC")
func Order(order string) Option {
	return func(db *gorm.DB) *gorm.DB {
		db = db.Order(order)
		return db
	}
}

// Select("name, sum(age) as total"), Group("name")
func Group(group string) Option {
	return func(db *gorm.DB) *gorm.DB {
		db = db.Group(group)
		return db
	}
}

// Select("name, sum(age) as total"), Group("name"), Having("name = ?", "john")
func Having(query interface{}, args ...interface{}) Option {
	return func(db *gorm.DB) *gorm.DB {
		db = db.Having(query, args...)
		return db
	}
}

// Limit(3) - Retrieve three users
func Limit(limit int) Option {
	return func(db *gorm.DB) *gorm.DB {
		db = db.Limit(limit)
		return db
	}
}

// Offset(2) - Select the third user
func Offset(offset int) Option {
	return func(db *gorm.DB) *gorm.DB {
		db = db.Offset(offset)
		return db
	}
}

/*
Joins specify Joins conditions

	Joins("Account")
	Joins("JOIN emails ON emails.user_id = users.id AND emails.email = ?", "johndoe@example.org")
*/
func Joins(query string, args ...interface{}) Option {
	return func(db *gorm.DB) *gorm.DB {
		db = db.Joins(query, args...)
		return db
	}
}

func applyOptions(db *gorm.DB, options ...Option) *gorm.DB {
	for _, option := range options {
		db = option(db)
	}
	return db
}

// PaginatedResults defines options for paginated queries.
type PaginatedResults[T any] struct {
	Page       int   `json:"page"`
	PageSize   int   `json:"page_size"`
	NumPages   int64 `json:"num_pages"`
	TotalCount int64 `json:"total_count"`
	HasNext    bool  `json:"has_next"`
	HasPrev    bool  `json:"has_prev"`
	Results    []T   `json:"results"`
}

// userService interface. Defines a CRUD interface for GORM ORM.
type userService interface {
	// Create new user
	Create(user *models.User, options ...Option) error

	// Get a single user by id (primary key)
	Get(id int64, options ...Option) (models.User, error)

	// Retrieves all users from the database
	GetAll(options ...Option) (results []models.User, err error)

	// Find the first record matching condition specified by query &amp; args
	FindOne(options ...Option) (models.User, error)

	// Find all records matching condition specified by query &amp; args
	FindMany(options ...Option) (results []models.User, err error)

	// GetPaginated retrieves a paginated list of users
	GetPaginated(page int, pageSize int, options ...Option) (*PaginatedResults[models.User], error)

	// Update user with all the fields. Uses gorm.DB.Save()
	Update(userId int64, user *models.User, options ...Option) (models.User, error)

	// Update a single column with specified conditions
	UpdateColumn(columnName string, args ...any) error

	// PartialUpdate for user. Only updates fields with non-zero values using gorm.DB.Updates(). Returns the updated user
	PartialUpdate(id int64, user models.User, options ...Option) (models.User, error)

	// Permanently Delete user from the database by primary key
	Delete(id int64) error

	// Permanently Delete user from the database matching conditions.
	DeleteWhere(value string, conds ...any) error
}

// Implementation for userService interface
type userRepo struct {
	DB *gorm.DB
}

// Returns a user service that accesses the gorm.DB
// instance through dependancy injection
func newUserService(db *gorm.DB) userService {
	return &userRepo{DB: db}
}

// Create new user
func (repo *userRepo) Create(user *models.User, options ...Option) error {
	if err := repo.DB.Create(&user).Error; err != nil {
		return err
	}

	// Refetch to load associations if any
	record, err := repo.Get(user.ID, options...)
	if err != nil {
		return err
	}
	*user = record
	return nil
}

// Get a single user by id primary key
// Warning: Do not pass Where() option in options when using id, you will get unexpected results.
// (unless that's what you want!)
func (repo *userRepo) Get(id int64, options ...Option) (models.User, error) {
	var user models.User
	db := repo.DB
	db = db.Preload("Tags.Issues")
	db = db.Preload("Role")
	db = applyOptions(db, options...)
	if err := db.First(&user, id).Error; err != nil {
		return models.User{}, err
	}
	return user, nil
}

// Retries all users
func (repo *userRepo) GetAll(options ...Option) (results []models.User, err error) {
	db := repo.DB
	db = db.Preload("Tags.Issues")
	db = db.Preload("Role")
	db = applyOptions(db, options...)
	err = db.Find(&results).Error
	return
}

// GetPaginated retrieves a paginated list of users
func (repo *userRepo) GetPaginated(page int, pageSize int, options ...Option) (
	*PaginatedResults[models.User], error) {

	var results []models.User

	// Retrieve total count of records
	var totalCount int64
	if err := repo.DB.Model(&models.User{}).Count(&totalCount).Error; err != nil {
		return nil, err
	}

	// Page must be >= 1
	if page < 1 {
		page = 1
	}

	// Calculate offset and limit
	offset := (page - 1) * pageSize

	// Query the database
	db := repo.DB
	db = db.Preload("Tags.Issues")
	db = db.Preload("Role")
	db = applyOptions(db, options...)

	if err := db.Offset(offset).Limit(pageSize).Find(&results).Error; err != nil {
		return nil, err
	}

	paginatedResults := &PaginatedResults[models.User]{
		Page:       page,
		PageSize:   pageSize,
		HasNext:    int64(page*pageSize) < totalCount,
		HasPrev:    page > 1,
		Results:    results,
		TotalCount: totalCount,
		NumPages:   int64(math.Ceil(float64(totalCount) / float64(pageSize))),
	}

	return paginatedResults, nil
}

func (repo *userRepo) FindOne(options ...Option) (models.User, error) {
	var user models.User
	db := repo.DB
	db = db.Preload("Tags.Issues")
	db = db.Preload("Role")
	db = applyOptions(db, options...)
	if err := db.First(&user).Error; err != nil {
		return models.User{}, err
	}
	return user, nil
}

func (repo *userRepo) FindMany(options ...Option) (results []models.User, err error) {
	db := repo.DB
	db = db.Preload("Tags.Issues")
	db = db.Preload("Role")
	db = applyOptions(db, options...)
	err = db.Find(&results).Error
	return
}

// Update user with all the fields. Uses gorm.DB.Save()
func (repo *userRepo) Update(id int64, user *models.User, options ...Option) (models.User, error) {
	if err := repo.DB.Save(user).Error; err != nil {
		return models.User{}, err
	}
	return repo.Get(id, options...)
}

// Update a single column
func (repo *userRepo) UpdateColumn(columnName string, args ...any) error {
	return repo.DB.Model(&models.User{}).UpdateColumn(columnName, args).Error
}

// PartialUpdate for user. Only updates fields with no zero values. Returns the updated user
func (repo *userRepo) PartialUpdate(id int64, user models.User, options ...Option) (models.User, error) {
	if err := repo.DB.Where("id=?", id).Model(&models.User{}).Updates(user).Error; err != nil {
		return models.User{}, err
	}

	var updateduser models.User
	db := repo.DB
	db = db.Preload("Tags.Issues")
	db = db.Preload("Role")
	db = applyOptions(db, options...)
	if err := db.First(&updateduser, id).Error; err != nil {
		return models.User{}, err
	}
	return updateduser, nil
}

// Permanently Delete user from the database by id
func (repo *userRepo) Delete(id int64) error {
	if err := repo.DB.Unscoped().Delete(&models.User{}, id).Error; err != nil {
		return err
	}
	return nil
}

// Permanently Delete user from the database matching conditions
func (repo *userRepo) DeleteWhere(value string, conds ...any) error {
	if err := repo.DB.Unscoped().Delete(&models.User{}, value, conds).Error; err != nil {
		return err
	}
	return nil
}

// roleService interface. Defines a CRUD interface for GORM ORM.
type roleService interface {
	// Create new role
	Create(role *models.Role, options ...Option) error

	// Get a single role by id (primary key)
	Get(id int64, options ...Option) (models.Role, error)

	// Retrieves all roles from the database
	GetAll(options ...Option) (results []models.Role, err error)

	// Find the first record matching condition specified by query &amp; args
	FindOne(options ...Option) (models.Role, error)

	// Find all records matching condition specified by query &amp; args
	FindMany(options ...Option) (results []models.Role, err error)

	// GetPaginated retrieves a paginated list of roles
	GetPaginated(page int, pageSize int, options ...Option) (*PaginatedResults[models.Role], error)

	// Update role with all the fields. Uses gorm.DB.Save()
	Update(roleId int64, role *models.Role, options ...Option) (models.Role, error)

	// Update a single column with specified conditions
	UpdateColumn(columnName string, args ...any) error

	// PartialUpdate for role. Only updates fields with non-zero values using gorm.DB.Updates(). Returns the updated role
	PartialUpdate(id int64, role models.Role, options ...Option) (models.Role, error)

	// Permanently Delete role from the database by primary key
	Delete(id int64) error

	// Permanently Delete role from the database matching conditions.
	DeleteWhere(value string, conds ...any) error
}

// Implementation for roleService interface
type roleRepo struct {
	DB *gorm.DB
}

// Returns a role service that accesses the gorm.DB
// instance through dependancy injection
func newRoleService(db *gorm.DB) roleService {
	return &roleRepo{DB: db}
}

// Create new role
func (repo *roleRepo) Create(role *models.Role, options ...Option) error {
	if err := repo.DB.Create(&role).Error; err != nil {
		return err
	}

	// Refetch to load associations if any
	record, err := repo.Get(role.ID, options...)
	if err != nil {
		return err
	}
	*role = record
	return nil
}

// Get a single role by id primary key
// Warning: Do not pass Where() option in options when using id, you will get unexpected results.
// (unless that's what you want!)
func (repo *roleRepo) Get(id int64, options ...Option) (models.Role, error) {
	var role models.Role
	db := repo.DB
	db = applyOptions(db, options...)
	if err := db.First(&role, id).Error; err != nil {
		return models.Role{}, err
	}
	return role, nil
}

// Retries all roles
func (repo *roleRepo) GetAll(options ...Option) (results []models.Role, err error) {
	db := repo.DB
	db = applyOptions(db, options...)
	err = db.Find(&results).Error
	return
}

// GetPaginated retrieves a paginated list of users
func (repo *roleRepo) GetPaginated(page int, pageSize int, options ...Option) (
	*PaginatedResults[models.Role], error) {

	var results []models.Role

	// Retrieve total count of records
	var totalCount int64
	if err := repo.DB.Model(&models.User{}).Count(&totalCount).Error; err != nil {
		return nil, err
	}

	// Page must be >= 1
	if page < 1 {
		page = 1
	}

	// Calculate offset and limit
	offset := (page - 1) * pageSize

	// Query the database
	db := repo.DB
	db = applyOptions(db, options...)

	if err := db.Offset(offset).Limit(pageSize).Find(&results).Error; err != nil {
		return nil, err
	}

	paginatedResults := &PaginatedResults[models.Role]{
		Page:       page,
		PageSize:   pageSize,
		HasNext:    int64(page*pageSize) < totalCount,
		HasPrev:    page > 1,
		Results:    results,
		TotalCount: totalCount,
		NumPages:   int64(math.Ceil(float64(totalCount) / float64(pageSize))),
	}

	return paginatedResults, nil
}

func (repo *roleRepo) FindOne(options ...Option) (models.Role, error) {
	var role models.Role
	db := repo.DB
	db = applyOptions(db, options...)
	if err := db.First(&role).Error; err != nil {
		return models.Role{}, err
	}
	return role, nil
}

func (repo *roleRepo) FindMany(options ...Option) (results []models.Role, err error) {
	db := repo.DB
	db = applyOptions(db, options...)
	err = db.Find(&results).Error
	return
}

// Update role with all the fields. Uses gorm.DB.Save()
func (repo *roleRepo) Update(id int64, role *models.Role, options ...Option) (models.Role, error) {
	if err := repo.DB.Save(role).Error; err != nil {
		return models.Role{}, err
	}
	return repo.Get(id, options...)
}

// Update a single column
func (repo *roleRepo) UpdateColumn(columnName string, args ...any) error {
	return repo.DB.Model(&models.Role{}).UpdateColumn(columnName, args).Error
}

// PartialUpdate for role. Only updates fields with no zero values. Returns the updated role
func (repo *roleRepo) PartialUpdate(id int64, role models.Role, options ...Option) (models.Role, error) {
	if err := repo.DB.Where("id=?", id).Model(&models.Role{}).Updates(role).Error; err != nil {
		return models.Role{}, err
	}

	var updatedrole models.Role
	db := repo.DB
	db = applyOptions(db, options...)
	if err := db.First(&updatedrole, id).Error; err != nil {
		return models.Role{}, err
	}
	return updatedrole, nil
}

// Permanently Delete role from the database by id
func (repo *roleRepo) Delete(id int64) error {
	if err := repo.DB.Unscoped().Delete(&models.Role{}, id).Error; err != nil {
		return err
	}
	return nil
}

// Permanently Delete role from the database matching conditions
func (repo *roleRepo) DeleteWhere(value string, conds ...any) error {
	if err := repo.DB.Unscoped().Delete(&models.Role{}, value, conds).Error; err != nil {
		return err
	}
	return nil
}

// tagService interface. Defines a CRUD interface for GORM ORM.
type tagService interface {
	// Create new tag
	Create(tag *models.Tag, options ...Option) error

	// Get a single tag by id (primary key)
	Get(id int64, options ...Option) (models.Tag, error)

	// Retrieves all tags from the database
	GetAll(options ...Option) (results []models.Tag, err error)

	// Find the first record matching condition specified by query &amp; args
	FindOne(options ...Option) (models.Tag, error)

	// Find all records matching condition specified by query &amp; args
	FindMany(options ...Option) (results []models.Tag, err error)

	// GetPaginated retrieves a paginated list of tags
	GetPaginated(page int, pageSize int, options ...Option) (*PaginatedResults[models.Tag], error)

	// Update tag with all the fields. Uses gorm.DB.Save()
	Update(tagId int64, tag *models.Tag, options ...Option) (models.Tag, error)

	// Update a single column with specified conditions
	UpdateColumn(columnName string, args ...any) error

	// PartialUpdate for tag. Only updates fields with non-zero values using gorm.DB.Updates(). Returns the updated tag
	PartialUpdate(id int64, tag models.Tag, options ...Option) (models.Tag, error)

	// Permanently Delete tag from the database by primary key
	Delete(id int64) error

	// Permanently Delete tag from the database matching conditions.
	DeleteWhere(value string, conds ...any) error
}

// Implementation for tagService interface
type tagRepo struct {
	DB *gorm.DB
}

// Returns a tag service that accesses the gorm.DB
// instance through dependancy injection
func newTagService(db *gorm.DB) tagService {
	return &tagRepo{DB: db}
}

// Create new tag
func (repo *tagRepo) Create(tag *models.Tag, options ...Option) error {
	if err := repo.DB.Create(&tag).Error; err != nil {
		return err
	}

	// Refetch to load associations if any
	record, err := repo.Get(tag.ID, options...)
	if err != nil {
		return err
	}
	*tag = record
	return nil
}

// Get a single tag by id primary key
// Warning: Do not pass Where() option in options when using id, you will get unexpected results.
// (unless that's what you want!)
func (repo *tagRepo) Get(id int64, options ...Option) (models.Tag, error) {
	var tag models.Tag
	db := repo.DB
	db = db.Preload("Issues")
	db = applyOptions(db, options...)
	if err := db.First(&tag, id).Error; err != nil {
		return models.Tag{}, err
	}
	return tag, nil
}

// Retries all tags
func (repo *tagRepo) GetAll(options ...Option) (results []models.Tag, err error) {
	db := repo.DB
	db = db.Preload("Issues")
	db = applyOptions(db, options...)
	err = db.Find(&results).Error
	return
}

// GetPaginated retrieves a paginated list of users
func (repo *tagRepo) GetPaginated(page int, pageSize int, options ...Option) (
	*PaginatedResults[models.Tag], error) {

	var results []models.Tag

	// Retrieve total count of records
	var totalCount int64
	if err := repo.DB.Model(&models.User{}).Count(&totalCount).Error; err != nil {
		return nil, err
	}

	// Page must be >= 1
	if page < 1 {
		page = 1
	}

	// Calculate offset and limit
	offset := (page - 1) * pageSize

	// Query the database
	db := repo.DB
	db = db.Preload("Issues")
	db = applyOptions(db, options...)

	if err := db.Offset(offset).Limit(pageSize).Find(&results).Error; err != nil {
		return nil, err
	}

	paginatedResults := &PaginatedResults[models.Tag]{
		Page:       page,
		PageSize:   pageSize,
		HasNext:    int64(page*pageSize) < totalCount,
		HasPrev:    page > 1,
		Results:    results,
		TotalCount: totalCount,
		NumPages:   int64(math.Ceil(float64(totalCount) / float64(pageSize))),
	}

	return paginatedResults, nil
}

func (repo *tagRepo) FindOne(options ...Option) (models.Tag, error) {
	var tag models.Tag
	db := repo.DB
	db = db.Preload("Issues")
	db = applyOptions(db, options...)
	if err := db.First(&tag).Error; err != nil {
		return models.Tag{}, err
	}
	return tag, nil
}

func (repo *tagRepo) FindMany(options ...Option) (results []models.Tag, err error) {
	db := repo.DB
	db = db.Preload("Issues")
	db = applyOptions(db, options...)
	err = db.Find(&results).Error
	return
}

// Update tag with all the fields. Uses gorm.DB.Save()
func (repo *tagRepo) Update(id int64, tag *models.Tag, options ...Option) (models.Tag, error) {
	if err := repo.DB.Save(tag).Error; err != nil {
		return models.Tag{}, err
	}
	return repo.Get(id, options...)
}

// Update a single column
func (repo *tagRepo) UpdateColumn(columnName string, args ...any) error {
	return repo.DB.Model(&models.Tag{}).UpdateColumn(columnName, args).Error
}

// PartialUpdate for tag. Only updates fields with no zero values. Returns the updated tag
func (repo *tagRepo) PartialUpdate(id int64, tag models.Tag, options ...Option) (models.Tag, error) {
	if err := repo.DB.Where("id=?", id).Model(&models.Tag{}).Updates(tag).Error; err != nil {
		return models.Tag{}, err
	}

	var updatedtag models.Tag
	db := repo.DB
	db = db.Preload("Issues")
	db = applyOptions(db, options...)
	if err := db.First(&updatedtag, id).Error; err != nil {
		return models.Tag{}, err
	}
	return updatedtag, nil
}

// Permanently Delete tag from the database by id
func (repo *tagRepo) Delete(id int64) error {
	if err := repo.DB.Unscoped().Delete(&models.Tag{}, id).Error; err != nil {
		return err
	}
	return nil
}

// Permanently Delete tag from the database matching conditions
func (repo *tagRepo) DeleteWhere(value string, conds ...any) error {
	if err := repo.DB.Unscoped().Delete(&models.Tag{}, value, conds).Error; err != nil {
		return err
	}
	return nil
}

// issueService interface. Defines a CRUD interface for GORM ORM.
type issueService interface {
	// Create new issue
	Create(issue *models.Issue, options ...Option) error

	// Get a single issue by id (primary key)
	Get(id int64, options ...Option) (models.Issue, error)

	// Retrieves all issues from the database
	GetAll(options ...Option) (results []models.Issue, err error)

	// Find the first record matching condition specified by query &amp; args
	FindOne(options ...Option) (models.Issue, error)

	// Find all records matching condition specified by query &amp; args
	FindMany(options ...Option) (results []models.Issue, err error)

	// GetPaginated retrieves a paginated list of issues
	GetPaginated(page int, pageSize int, options ...Option) (*PaginatedResults[models.Issue], error)

	// Update issue with all the fields. Uses gorm.DB.Save()
	Update(issueId int64, issue *models.Issue, options ...Option) (models.Issue, error)

	// Update a single column with specified conditions
	UpdateColumn(columnName string, args ...any) error

	// PartialUpdate for issue. Only updates fields with non-zero values using gorm.DB.Updates(). Returns the updated issue
	PartialUpdate(id int64, issue models.Issue, options ...Option) (models.Issue, error)

	// Permanently Delete issue from the database by primary key
	Delete(id int64) error

	// Permanently Delete issue from the database matching conditions.
	DeleteWhere(value string, conds ...any) error
}

// Implementation for issueService interface
type issueRepo struct {
	DB *gorm.DB
}

// Returns a issue service that accesses the gorm.DB
// instance through dependancy injection
func newIssueService(db *gorm.DB) issueService {
	return &issueRepo{DB: db}
}

// Create new issue
func (repo *issueRepo) Create(issue *models.Issue, options ...Option) error {
	if err := repo.DB.Create(&issue).Error; err != nil {
		return err
	}

	// Refetch to load associations if any
	record, err := repo.Get(issue.ID, options...)
	if err != nil {
		return err
	}
	*issue = record
	return nil
}

// Get a single issue by id primary key
// Warning: Do not pass Where() option in options when using id, you will get unexpected results.
// (unless that's what you want!)
func (repo *issueRepo) Get(id int64, options ...Option) (models.Issue, error) {
	var issue models.Issue
	db := repo.DB
	db = applyOptions(db, options...)
	if err := db.First(&issue, id).Error; err != nil {
		return models.Issue{}, err
	}
	return issue, nil
}

// Retries all issues
func (repo *issueRepo) GetAll(options ...Option) (results []models.Issue, err error) {
	db := repo.DB
	db = applyOptions(db, options...)
	err = db.Find(&results).Error
	return
}

// GetPaginated retrieves a paginated list of users
func (repo *issueRepo) GetPaginated(page int, pageSize int, options ...Option) (
	*PaginatedResults[models.Issue], error) {

	var results []models.Issue

	// Retrieve total count of records
	var totalCount int64
	if err := repo.DB.Model(&models.User{}).Count(&totalCount).Error; err != nil {
		return nil, err
	}

	// Page must be >= 1
	if page < 1 {
		page = 1
	}

	// Calculate offset and limit
	offset := (page - 1) * pageSize

	// Query the database
	db := repo.DB
	db = applyOptions(db, options...)

	if err := db.Offset(offset).Limit(pageSize).Find(&results).Error; err != nil {
		return nil, err
	}

	paginatedResults := &PaginatedResults[models.Issue]{
		Page:       page,
		PageSize:   pageSize,
		HasNext:    int64(page*pageSize) < totalCount,
		HasPrev:    page > 1,
		Results:    results,
		TotalCount: totalCount,
		NumPages:   int64(math.Ceil(float64(totalCount) / float64(pageSize))),
	}

	return paginatedResults, nil
}

func (repo *issueRepo) FindOne(options ...Option) (models.Issue, error) {
	var issue models.Issue
	db := repo.DB
	db = applyOptions(db, options...)
	if err := db.First(&issue).Error; err != nil {
		return models.Issue{}, err
	}
	return issue, nil
}

func (repo *issueRepo) FindMany(options ...Option) (results []models.Issue, err error) {
	db := repo.DB
	db = applyOptions(db, options...)
	err = db.Find(&results).Error
	return
}

// Update issue with all the fields. Uses gorm.DB.Save()
func (repo *issueRepo) Update(id int64, issue *models.Issue, options ...Option) (models.Issue, error) {
	if err := repo.DB.Save(issue).Error; err != nil {
		return models.Issue{}, err
	}
	return repo.Get(id, options...)
}

// Update a single column
func (repo *issueRepo) UpdateColumn(columnName string, args ...any) error {
	return repo.DB.Model(&models.Issue{}).UpdateColumn(columnName, args).Error
}

// PartialUpdate for issue. Only updates fields with no zero values. Returns the updated issue
func (repo *issueRepo) PartialUpdate(id int64, issue models.Issue, options ...Option) (models.Issue, error) {
	if err := repo.DB.Where("id=?", id).Model(&models.Issue{}).Updates(issue).Error; err != nil {
		return models.Issue{}, err
	}

	var updatedissue models.Issue
	db := repo.DB
	db = applyOptions(db, options...)
	if err := db.First(&updatedissue, id).Error; err != nil {
		return models.Issue{}, err
	}
	return updatedissue, nil
}

// Permanently Delete issue from the database by id
func (repo *issueRepo) Delete(id int64) error {
	if err := repo.DB.Unscoped().Delete(&models.Issue{}, id).Error; err != nil {
		return err
	}
	return nil
}

// Permanently Delete issue from the database matching conditions
func (repo *issueRepo) DeleteWhere(value string, conds ...any) error {
	if err := repo.DB.Unscoped().Delete(&models.Issue{}, value, conds).Error; err != nil {
		return err
	}
	return nil
}

// Service embeds all generated services
type Service struct {
	UserService  userService
	RoleService  roleService
	TagService   tagService
	IssueService issueService
}

// Returns a new Service that embeds all the generated services.
func NewService(db *gorm.DB) *Service {
	return &Service{
		UserService:  newUserService(db),
		RoleService:  newRoleService(db),
		TagService:   newTagService(db),
		IssueService: newIssueService(db),
	}
}
