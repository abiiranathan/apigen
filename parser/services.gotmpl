{{if .WritePKGDecl}}
// Code generated by "apigen"; DO NOT EDIT.

package {{.PkgName}}

import (
	{{ range .ModelPkgs }}
		"{{ . }}"
	{{- end }}
	"gorm.io/gorm"
	"database/sql"
	"math"
)

/*
Options to pass to GORM.
Preferred order of option: Select,Group, Where, Or, Joins, Preload, Order, Limit, Offset, etc

	Select("column1, column2").
    Where("column3 = ?", value).
    Joins("JOIN t1 ON t1.id = t.id").
    Order("column ASC").
    Limit(10).
    Offset(0).
    Find(&results)
*/
type Option func(db *gorm.DB)*gorm.DB

// Options is a list of Option
type Options []Option

/*
Where add conditions
See the docs for details on the various formats that where clauses can take. By default, where clauses chain with AND.

	Find the first user with name john
	Where("name = ?", "john")

*/
func Where(query string, args...any) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Where(query, args...)
		return db
	}
}

/*
Preload preload associations with given conditions

	Preload("Orders", "state NOT IN (?)", "cancelled")
*/
func Preload(query string, args...any) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Preload(query, args...)
		return db
	}
}

/*
Select specify fields that you want when querying, creating, updating

Use Select when you only want a subset of the fields. 
By default, GORM will select all fields.

	Select("name", "age")
*/
func Select(columns ...string) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Select(columns)
		return db
	}
}

// Omit specify fields that you want to ignore when creating, updating and querying
func Omit(columns ...string) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Omit(columns...)
		return db
	}
}


// Order("name DESC")
func Order(order string) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Order(order)
		return db
	}
}


// Select("name, sum(age) as total"), Group("name")
func Group(group string) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Group(group)
		return db
	}
}


// Select("name, sum(age) as total"), Group("name"), Having("name = ?", "john")
func Having(query interface{}, args ...interface{}) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Having(query, args ...)
		return db
	}
}


// Limit(3) - Retrieve three users
func Limit(limit int) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Limit(limit)
		return db
	}
}


// Distinct(args ...any) - Specify Distinct columns
func Distinct(args ...any) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Distinct(args...)
		return db
	}
}

//	Offset(2) - Select the third user
func Offset(offset int) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Offset(offset)
		return db
	}
}

/*
Joins specify Joins conditions

	Joins("Account")
	Joins("JOIN emails ON emails.user_id = users.id AND emails.email = ?", "johndoe@example.org")
*/
func Joins(query string, args ...interface{}) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Joins(query, args...)
		return db
	}
}

func Or(query interface{}, args ...interface{}) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Or(query, args...)
		return db
	}
}

// Scopes pass current database connection to arguments `func(db *gorm.DB) *gorm.DB`, which could be used to add conditions dynamically
func Scopes(funcs ...func(db *gorm.DB) *gorm.DB) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Scopes(funcs...)
		return db
	}
}

// Unscoped return all record including deleted record, refer Soft Delete
func Unscoped() Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Unscoped()
		return db
	}
}

// Attrs initialize struct with argument if record not found with Where
func Attrs(attrs ...any) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Attrs(attrs...)
		return db
	}
}

// Assign assign result with argument regardless it is found or not
func Assign(attrs ...any) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Assign(attrs...)
		return db
	}
}

// DateRange applies date range filter on a date column
func DateRange(column string, start, end string) Option{
	return func(db *gorm.DB) *gorm.DB{
		if start != "" && end != "" {
			db = db.Where(column+" BETWEEN ? AND ?", start, end)
		}else if start != "" {
			db = db.Where(column+" >= ?", start)
		}else if end != "" {
			db = db.Where(column+" <= ?", end)
		}
		return db
	}
}


// ILIKE applies case-insensitive search on a column.
// If a value is empty, it does nothing.
func ILIKE(column, value string) Option{
	return func(db *gorm.DB) *gorm.DB{
		if value != "" {
			db = db.Where(column+" ILIKE ?", "%"+value+"%")
		}
		return db
	}
}

func applyOptions(db *gorm.DB, options ...Option) *gorm.DB {
	for _, option := range options{
		db = option(db)
	}
	return db
}


// PaginatedResults defines options for paginated queries.
type PaginatedResults[T any] struct {
    Page     int  `json:"page"`
    PageSize int `json:"page_size"`
    TotalPages  int64  `json:"total_pages"`
    Count  int64  `json:"count"`
    HasNext  bool `json:"has_next"`
    HasPrev  bool `json:"has_prev"`
    Results  []T  `json:"results"`
}

{{ end }}


{{ $ident:=.Model | ToLower }}
{{ $pkType := .ModelObj.PKType }}

{{ if not .SkipService }}
type {{$ident}}Service interface {
	{{ if not .PkgReadOnly }}
		// Create new {{$ident}}
		Create({{$ident}} *{{.ModelPkgName}}.{{.Model}}, options ...Option) error

		// Create multiple {{$ident}}s
		CreateMany({{$ident}}s *[]{{.ModelPkgName}}.{{.Model}}, options ...Option) error

		{{ if ne $pkType "" }}
			// Update {{$ident}} with all the fields. Uses gorm.DB.Save()
			Update({{$ident}}Id {{$pkType}}, {{$ident}} *{{.ModelPkgName}}.{{.Model}}, options ...Option) ({{.ModelPkgName}}.{{.Model}}, error)
		{{ end }}

		// Update a single column with specified conditions
		UpdateColumn(columnName string, value any, query string, args ...any) error

		{{ if ne $pkType "" }}
			// PartialUpdate for {{$ident}}. Only updates fields with non-zero values using gorm.DB.Updates(). Returns the updated {{$ident}}
			PartialUpdate(id {{$pkType}}, {{$ident}} {{.ModelPkgName}}.{{.Model}}, options ...Option) ({{.ModelPkgName}}.{{.Model}}, error)
		{{ end }}

		{{ if ne $pkType "" }}
			// Permanently Delete {{$ident}} from the database by primary key
			Delete(id {{$pkType}}) error
		{{ end }}

		// Permanently Delete {{$ident}} from the database matching conditions.
		DeleteWhere(value string, conds ...any) error

		// Begin returns a new instance of {{$ident}}Service that runs all queries in a transaction.
		// Call Rollback() to undo changes and Commit() to Commit the changes.
		Begin(opts ...*sql.TxOptions)({{$ident}}Service, error)

		// Commit all transactions run with the service.
		Commit() error

		// Rollback transaction.
		Rollback() error
	{{ end }}

	{{ if ne $pkType "" }}
		// Get a single {{$ident}} by id (primary key)
		Get(id {{$pkType}}, options ...Option) ({{.ModelPkgName}}.{{.Model}}, error)
	{{ end }}

	// Retrieves all {{$ident}}s from the database
	GetAll(options ...Option) (results []{{.ModelPkgName}}.{{.Model}}, err error)

	// Count returns the number of records matching the query
	Count(options ...Option) (int64, error)

	// Find the first record matching condition specified by query &amp; args
	FindOne(options ...Option) ({{.ModelPkgName}}.{{.Model}}, error)

	// Find all records matching condition specified by query &amp; args
	FindMany(options ...Option) (results []{{.ModelPkgName}}.{{.Model}}, err error)

	// GetPaginated retrieves a paginated list of {{$ident}}s
	GetPaginated(page int, pageSize int, options ...Option) (*PaginatedResults[{{.ModelPkgName}}.{{.Model}}], error)

}

// Implementation for {{$ident}}Service interface
type {{$ident}}Repo struct {
	DB *gorm.DB
}

// Returns a {{$ident}} service that accesses the gorm.DB
// instance through dependancy injection
func new{{.Model}}Service(db *gorm.DB) {{$ident}}Service {
	return &{{$ident}}Repo{DB: db}
}

{{ if not .PkgReadOnly }}
// Create new {{$ident}}
func (repo *{{$ident}}Repo) CreateMany({{$ident}}s *[]{{.ModelPkgName}}.{{.Model}}, options ...Option) error {
	if err := repo.DB.Omit({{ join .OmitFields ","}}).Create({{$ident}}s).Error; err != nil{
		return err
	}

	// Refetch to load associations if any
	for i, record := range *{{$ident}}s{
		record, err := repo.Get(record.ID, options...)
		if err != nil {
			return  err
		}
		(*{{$ident}}s)[i]=record
	}
	return nil
}

// Create new {{$ident}}
func (repo *{{$ident}}Repo) Create({{$ident}} *{{.ModelPkgName}}.{{.Model}}, options ...Option) error {
	if err := repo.DB.Omit({{ join .OmitFields ","}}).Create({{$ident}}).Error; err != nil{
		return err
	}

	// Refetch to load associations if any
	record, err := repo.Get({{$ident}}.ID, options...)
	if err != nil {
		return  err
	}
	*{{$ident}}=record
	return nil
}

{{ if ne $pkType "" }}
	// Update {{$ident}} with all the fields. Uses gorm.DB.Save()
	func (repo *{{$ident}}Repo) Update(id {{$pkType}}, {{$ident}} *{{.ModelPkgName}}.{{.Model}}, options...Option) ({{.ModelPkgName}}.{{.Model}}, error) {
		// Make sure the ID is set on object to use Save(), otherwise you get unique constraint error.
		{{$ident}}.ID = id
		if err := repo.DB.Omit({{ join .OmitFields ","}}).Save({{$ident}}).Error; err != nil {
			return {{.ModelPkgName}}.{{.Model}}{}, err
		}
		return repo.Get(id, options...)
	}
{{ end }}

// Update a single column. Gorm hooks will be fired because it uses Update() method.
func (repo *{{$ident}}Repo) UpdateColumn(columnName string, value any, query string, args ...any) error{
	return repo.DB.Model(&{{.ModelPkgName}}.{{.Model}}{}).Where(query, args...).Update(columnName, value).Error;	
}

{{ if ne $pkType "" }}
	// PartialUpdate for {{$ident}}. Only updates fields with no zero values. Returns the updated {{$ident}}
	func (repo *{{$ident}}Repo) PartialUpdate(id {{$pkType}}, {{$ident}} {{.ModelPkgName}}.{{.Model}}, options...Option) ({{.ModelPkgName}}.{{.Model}}, error) {
		if err := repo.DB.Omit({{ join .OmitFields ","}}).Where("id=?", id).Model(&{{.ModelPkgName}}.{{.Model}}{}).Updates({{$ident}}).Error; err != nil {
			return {{.ModelPkgName}}.{{.Model}}{}, err
		}

		var updated{{$ident}} {{.ModelPkgName}}.{{.Model}}
		db := repo.DB
		{{range $preloadStmt := .Preloads -}}
			db = db.Preload("{{$preloadStmt}}")
		{{end -}}

		db = applyOptions(db, options...)
		if err := db.First(&updated{{$ident}}, id).Error; err != nil {
			return {{.ModelPkgName}}.{{.Model}}{}, err
		}
		return updated{{$ident}}, nil
	}
{{ end }}

{{ if ne $pkType "" }}
	// Permanently Delete {{$ident}} from the database by id
	func (repo *{{$ident}}Repo) Delete(id {{$pkType}}) error {
		if err := repo.DB.Unscoped().Delete(&{{.ModelPkgName}}.{{.Model}}{}, id).Error; err != nil {
			return err
		}
		return nil
	}
{{ end }}

// Permanently Delete {{$ident}} from the database matching conditions
func (repo *{{$ident}}Repo) DeleteWhere(value string, conds ...any) error {
	if err :=  repo.DB.Unscoped().Delete(&{{.ModelPkgName}}.{{.Model}}{}, value, conds).Error; err != nil {
		return err
	}
	return nil
}


// Begin returns a new instance of {{$ident}}Service that runs all queries in a transaction.
// Call Rollback() to undo changes and Commit() to Commit the changes.
func (repo *{{$ident}}Repo) Begin(opts ...*sql.TxOptions)({{$ident}}Service, error){
	tx := repo.DB.Begin(opts...)
	if tx.Error != nil{
		return nil, tx.Error
	}
	return new{{.Model}}Service(tx), nil
}

// Commit all transactions run with the service. Must have called .Begin() before.
func (repo *{{$ident}}Repo) Commit() error{
	return repo.DB.Commit().Error
}

// Rollback transaction on error.
func (repo *{{$ident}}Repo) Rollback() error{
	return repo.DB.Rollback().Error
}

{{ end }}

{{ if ne $pkType "" }}
// Make sure struct has an ID field as PK.
// Else skip this.
// Get a single {{$ident}} by id primary key
// Warning: Do not pass Where() option in options when using id, you will get unexpected results.
// (unless that's what you want!)
func (repo *{{$ident}}Repo) Get(id {{$pkType}}, options ...Option) ({{.ModelPkgName}}.{{.Model}}, error) {
	var {{$ident}} {{.ModelPkgName}}.{{.Model}}
	db := repo.DB
	{{range $preloadStmt := .Preloads -}}
		db = db.Preload("{{$preloadStmt}}")
	{{end -}}

	db = applyOptions(db, options...)
	if err := db.First(&{{$ident}}, id).Error; err != nil {
		return {{.ModelPkgName}}.{{.Model}}{}, err
	}
	return {{$ident}}, nil
}
{{ end }}

// Retries all {{$ident}}s
func (repo *{{$ident}}Repo) GetAll(options ...Option) (results []{{.ModelPkgName}}.{{.Model}}, err error) {
	db := repo.DB
	{{range $preloadStmt := .Preloads -}}
    	db = db.Preload("{{$preloadStmt}}")
	{{end -}}

	db = applyOptions(db, options...)
	err = db.Find(&results).Error
	return
}

// Count returns the number of records matching the query
func (repo *{{$ident}}Repo) Count(options ...Option) (int64, error) {
	var count int64
	db := repo.DB
	db = applyOptions(db, options...)
	if err := db.Model(&{{.ModelPkgName}}.{{.Model}}{}).Count(&count).Error; err != nil {
		return 0, err
	}
	return count, nil
}

// GetPaginated retrieves a paginated list of users
func (repo *{{$ident}}Repo) GetPaginated(page int, pageSize int, options ...Option) (
	*PaginatedResults[{{.ModelPkgName}}.{{.Model}}], error) {

	var results []{{.ModelPkgName}}.{{.Model}}

	// Page must be >= 1
	if page < 1 {
		page = 1
	}

	// Calculate offset and limit
	offset := (page - 1) * pageSize

	// Query the database
	db := repo.DB
	{{range $preloadStmt := .Preloads -}}
    	db = db.Preload("{{$preloadStmt}}")
	{{end -}}
	db = applyOptions(db, options...)

	// Retrieve total count of records after applying options
	var totalCount int64
	if err := db.Model(&{{.ModelPkgName}}.{{.Model}}{}).Count(&totalCount).Error; err != nil {
		return nil, err
	}

	if err := db.Offset(offset).Limit(pageSize).Find(&results).Error; err != nil{
		return nil, err
	}

	paginatedResults := &PaginatedResults[{{.ModelPkgName}}.{{.Model}}]{
		Page:     page,
		PageSize: pageSize,
		HasNext:  int64(page*pageSize) < totalCount,
		HasPrev:  page > 1,
		Results: results,
		Count: totalCount,
		TotalPages:   int64(math.Ceil(float64(totalCount) / float64(pageSize))),
	}

	return paginatedResults, nil
}


func (repo *{{$ident}}Repo) FindOne(options ...Option) ({{.ModelPkgName}}.{{.Model}}, error){
	var {{$ident}} {{.ModelPkgName}}.{{.Model}}
	db := repo.DB
	{{range $preloadStmt := .Preloads -}}
    	db = db.Preload("{{$preloadStmt}}")
	{{end -}}

	db = applyOptions(db, options...)
	if err := db.First(&{{$ident}}).Error; err != nil {
		return {{.ModelPkgName}}.{{.Model}}{}, err
	}
	return {{$ident}}, nil
}

func (repo *{{$ident}}Repo) FindMany(options ...Option) (results []{{.ModelPkgName}}.{{.Model}}, err error){
	db := repo.DB
	{{range $preloadStmt := .Preloads -}}
    	db = db.Preload("{{$preloadStmt}}")
	{{end -}}
	
	db = applyOptions(db, options...)
	err = db.Find(&results).Error
	return
}

{{ end }}