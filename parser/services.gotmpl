{{if .WritePKGDecl}}
// Code generated by "apigen"; DO NOT EDIT.

package {{.PkgName}}

import (
	{{ range .ModelPkgs }}
		"{{ . }}"
	{{- end }}
	"context"
	"gorm.io/gorm"
    "gorm.io/gorm/clause"
	"database/sql"
	"math"
)

/*
Options to pass to GORM.
Preferred order of option: Select,Group, Where, Or, Joins, Preload, Order, Limit, Offset, etc

	Select("column1, column2").
    Where("column3 = ?", value).
    Joins("JOIN t1 ON t1.id = t.id").
    Order("column ASC").
    Limit(10).
    Offset(0).
    Find(&results)
*/
type Option func(db *gorm.DB)*gorm.DB

// Options is a list of Option
// It has methods to update the options in-place like Where, ILIKE, Order etc.
// Preferred order of options: Select, Group, Where, Or, Joins, Preload, Order, Limit, Offset, etc
type Options []Option

// NewOptions creates a new Options slice with the specified capacity
func NewOptions(capacity int) *Options {
    opts := make(Options, 0, capacity)
    return &opts
}

/*
Where add conditions
See the docs for details on the various formats that where clauses can take. By default, where clauses chain with AND.

	Find the first user with name john
	Where("name = ?", "john")

*/
func Where(query string, args...any) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Where(query, args...)
		return db
	}
}

// Model sets the model to use for the query
func Model(value interface{}) Option{
    return func(db *gorm.DB) *gorm.DB{
        db = db.Model(value)
        return db
    }
}

func WhereIf(condition bool, query string, args...any) Option{
    return func(db *gorm.DB) *gorm.DB{
        if condition {
            db = db.Where(query, args...)
        }
        return db
    }
}


// Helper function to create pass a single Where clause.
// This is different from the Where Option.
func WHERE(query string, args...any) *Options{
    return &Options{Where(query, args...)}
}

/*
Preload preload associations with given conditions

	Preload("Orders", "state NOT IN (?)", "cancelled")
*/
func Preload(query string, args...any) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Preload(query, args...)
		return db
	}
}

/*
Select specify fields that you want when querying, creating, updating

Use Select when you only want a subset of the fields. 
By default, GORM will select all fields.

	Select("name", "age")
*/
func Select(columns ...string) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Select(columns)
		return db
	}
}

// Omit specify fields that you want to ignore when creating, updating and querying
func Omit(columns ...string) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Omit(columns...)
		return db
	}
}

// Order("name DESC")
func Order(order string) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Order(order)
		return db
	}
}

// Select("name, sum(age) as total"), Group("name")
func Group(group string) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Group(group)
		return db
	}
}


// Select("name, sum(age) as total"), Group("name"), Having("name = ?", "john")
func Having(query interface{}, args ...interface{}) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Having(query, args ...)
		return db
	}
}


// Limit(3) - Retrieve three users
func Limit(limit int) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Limit(limit)
		return db
	}
}

// Distinct(args ...any) - Specify Distinct columns
func Distinct(args ...any) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Distinct(args...)
		return db
	}
}

//	Offset(2) - Select the third user
func Offset(offset int) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Offset(offset)
		return db
	}
}

/*
Joins specify Joins conditions

	Joins("Account")
	Joins("JOIN emails ON emails.user_id = users.id AND emails.email = ?", "johndoe@example.org")
*/
func Joins(query string, args ...interface{}) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Joins(query, args...)
		return db
	}
}

func Or(query interface{}, args ...interface{}) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Or(query, args...)
		return db
	}
}

// Specify table name to run the query
func Table(name string) Option{
    return func(db *gorm.DB) *gorm.DB{
        db = db.Table(name)
        return db
    }
}

// Clauses accepts multiple conditions 
func Clauses(conds ...clause.Expression) Option{
    return func(db *gorm.DB) *gorm.DB{
        db = db.Clauses(conds...)
        return db
    }
}

// Not clause to exclude records that match the condition
func Not(query interface{}, args ...interface{}) Option{
    return func(db *gorm.DB) *gorm.DB{
		db = db.Not(query, args...)
		return db
	}
}


// Scopes pass current database connection to arguments `func(db *gorm.DB) *gorm.DB`, which could be used to add conditions dynamically
func Scopes(funcs ...func(db *gorm.DB) *gorm.DB) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Scopes(funcs...)
		return db
	}
}

// Unscoped return all record including deleted record, refer Soft Delete
func Unscoped() Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Unscoped()
		return db
	}
}

// Attrs initialize struct with argument if record not found with Where
func Attrs(attrs ...any) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Attrs(attrs...)
		return db
	}
}

// Assign assign result with argument regardless it is found or not
func Assign(attrs ...any) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Assign(attrs...)
		return db
	}
}

// DateRange applies date range filter on a date column
// e.g DateRange("DATE(created_at)", "2021-01-01", "2021-12-31")
// It does nothing if start or end is empty.
func DateRange(column string, start, end string) Option{
	return func(db *gorm.DB) *gorm.DB{
		if start != "" && end != "" {
			db = db.Where(column+" BETWEEN ? AND ?", start, end)
		}else if start != "" {
			db = db.Where(column+" >= ?", start)
		}else if end != "" {
			db = db.Where(column+" <= ?", end)
		}
		return db
	}
}


// MothRange is the same as date range but truncates the date to month
// e.g MonthRange("DATE(created_at)", "2021-01-01", "2021-12-31")
// It does nothing if start or end is empty.
func MonthRange(column string, start, end string) Option{
    return func(db *gorm.DB) *gorm.DB{
        if start != "" && end != "" {
            db = db.Where(column +" BETWEEN DATE_TRUNC('month', ?::DATE) AND DATE_TRUNC('month', ?::DATE)", start, end)
        }else if start != "" {
            db = db.Where(column +" >= DATE_TRUNC('month', ?::DATE)", start)
        }else if end != "" {
            db = db.Where(column +" <= DATE_TRUNC('month', ?::DATE)", end)
        }
        return db
    }
}

// YearRange is the same as date range but truncates the date to year
// e.g YearRange("DATE(created_at)", "2021-01-01", "2024-12-31")
// It does nothing if start or end is empty.
func YearRange(column string, start, end string) Option{
    return func(db *gorm.DB) *gorm.DB{
        if start != "" && end != "" {
            db = db.Where(column +" BETWEEN DATE_TRUNC('year', ?::DATE) AND DATE_TRUNC('year', ?::DATE)", start, end)
        }else if start != "" {
            db = db.Where(column +" >= DATE_TRUNC('year', ?::DATE)", start)
        }else if end != "" {
            db = db.Where(column +" <= DATE_TRUNC('year', ?::DATE)", end)
        }
        return db
    }
}


// ILIKE applies case-insensitive search on a column.
// If a value is empty, it does nothing.
func ILIKE(column, value string) Option{
	return func(db *gorm.DB) *gorm.DB{
		if value != "" {
			db = db.Where(column+" ILIKE ?", "%"+value+"%")
		}
		return db
	}
}

func WithContext(ctx context.Context) Option {
	return func(db *gorm.DB) *gorm.DB{
		db = db.WithContext(ctx)
		return db
	}
}

func applyOptions(db *gorm.DB, options ...*Options) *gorm.DB {
    // we care about the first options only
    if(len(options) == 0){
        return db
    }
    opts := *options[0]

	for _, option := range opts{
		db = option(db)
	}
	return db
}

func (opts *Options) Where(query string, args ...any) *Options {
    *opts = append(*opts, Where(query, args...))
    return opts
}


func (opts *Options) WhereIf(condition bool, query string, args ...any) *Options {
    if condition {
        *opts = append(*opts, Where(query, args...))
    }
    return opts
}

// Select adds a Select clause to the options
func (opts *Options) Select(columns ...string) *Options {
    *opts = append(*opts, Select(columns...))
    return opts
}

// Preload adds a Preload clause to the options
func (opts *Options) Preload(query string, args ...any) *Options {
    *opts = append(*opts, Preload(query, args...))
    return opts
}

// Order adds an Order clause to the options
func (opts *Options) Order(order string) *Options{
    *opts = append(*opts, Order(order))
    return opts
}

// Limit adds a Limit clause to the options
func (opts *Options) Limit(limit int) *Options {
    *opts = append(*opts, Limit(limit))
    return opts
}

// Offset adds an Offset clause to the options
func (opts *Options) Offset(offset int) *Options {
    *opts = append(*opts, Offset(offset))
    return opts
}

// Joins adds a Joins clause to the options
func (opts *Options) Joins(query string, args ...interface{}) *Options {
    *opts = append(*opts, Joins(query, args...))
    return opts
}

// Group adds a Group clause to the options
func (opts *Options) Group(group string) *Options {
    *opts = append(*opts, Group(group))
    return opts
}

// Having adds a Having clause to the options
func (opts *Options) Having(query interface{}, args ...interface{}) *Options {
    *opts = append(*opts, Having(query, args...))
    return opts
}

// Distinct adds a Distinct clause to the options
func (opts *Options) Distinct(args ...any) *Options {
    *opts = append(*opts, Distinct(args...))
    return opts
}

// Or adds an Or clause to the options
func (opts *Options) Or(query interface{}, args ...interface{}) *Options {
    *opts = append(*opts, Or(query, args...))
    return opts
}

// Scopes adds Scopes to the options
func (opts *Options) Scopes(funcs ...func(db *gorm.DB) *gorm.DB) *Options {
    *opts = append(*opts, Scopes(funcs...))
    return opts
}

// Unscoped adds an Unscoped clause to the options
func (opts *Options) Unscoped() *Options {
    *opts = append(*opts, Unscoped())
    return opts
}

// DateRange adds a date range filter to the options
func (opts *Options) DateRange(column string, start, end string) *Options {
    *opts = append(*opts, DateRange(column, start, end))
    return opts
}

// MonthRange adds a month range filter to the options
func (opts *Options) MonthRange(column string, start, end string) *Options {
    *opts = append(*opts, MonthRange(column, start, end))
    return opts
}

// YearRange adds a year range filter to the options
func (opts *Options) YearRange(column string, start, end string) *Options {
    *opts = append(*opts, YearRange(column, start, end))
    return opts
}

// Model sets the model to use for the query
func (opts *Options) Model(value interface{}) *Options {
    *opts = append(*opts, Model(value))
    return opts
}

// ILIKE adds a case-insensitive search to the options
func (opts *Options) ILIKE(column, value string) *Options {
    *opts = append(*opts, ILIKE(column, value))
    return opts
}

// WithContext applies custom context to be passed to GORM.
func (opts *Options) WithContext(ctx context.Context) *Options {
    *opts = append(*opts, WithContext(ctx))
    return opts
}

// Table configures the table name for the query
func (opts *Options) Table(name string) *Options {
    *opts = append(*opts, Table(name))
    return opts
}

// Clauses adds multiple conditions to the options
func (opts *Options) Clauses(conds ...clause.Expression) *Options {
    *opts = append(*opts, Clauses(conds...))
    return opts
}

// Not adds a Not clause to the options
func (opts *Options) Not(query interface{}, args ...interface{}) *Options {
    *opts = append(*opts, Not(query, args...))
    return opts
}

// Attrs adds an Attrs clause to the options
func (opts *Options) Attrs(attrs ...any) *Options {
    *opts = append(*opts, Attrs(attrs...))
    return opts
}

// Assign provide attributes used in FirstOrCreate or FirstOrInit
//
// Assign adds attributes even if the record is found. 
// If using FirstOrCreate, this means that records will be updated even if they are found.
// See db.Assign gorm docs for more details.
func (opts *Options) Assign(attrs ...any) *Options {
    *opts = append(*opts, Assign(attrs...))
    return opts
}

// Append new options and return updated options
// This allows chaining of options.
func (opts *Options) Append(option ...Option) *Options {
    *opts = append(*opts, option...)
    return opts
}

// Append options only if condition is true
func (opts *Options) AppendIf(condition bool, option ...Option) *Options {
    if condition {
        *opts = append(*opts, option...)
    }
    return opts
}

// Apply the options to the db instance and return the updated db instance
func (opts *Options) Apply(db *gorm.DB) *gorm.DB {
    return applyOptions(db, opts)
}

// PaginatedResults defines options for paginated queries.
type PaginatedResults[T any] struct {
    Page     int  `json:"page"`
    PageSize int `json:"page_size"`
    TotalPages  int64  `json:"total_pages"`
    Count  int64  `json:"count"`
    HasNext  bool `json:"has_next"`
    HasPrev  bool `json:"has_prev"`
    Results  []T  `json:"results"`
}

{{ end }}

{{ $ident:=.Model | ToLower }}
{{ $pkType := .ModelObj.PKType }}

{{ if not .SkipService }}
type {{$ident}}Service interface {
	{{ if not .PkgReadOnly }}
		// Create new {{$ident}}
		Create({{$ident}} *{{.ModelPkgName}}.{{.Model}}, options ...*Options) error

		// Create multiple {{$ident}}s
		CreateMany({{$ident}}s *[]{{.ModelPkgName}}.{{.Model}}, options ...*Options) error

		{{ if ne $pkType "" }}
			// Update {{$ident}} with all the fields. Uses gorm.DB.Save()
			Update({{$ident}}Id {{$pkType}}, {{$ident}} *{{.ModelPkgName}}.{{.Model}}, options ...*Options)  (*{{.ModelPkgName}}.{{.Model}}, error)
		{{ end }}

		// Update a single column with specified conditions
		UpdateColumn(columnName string, value any, query string, args ...any) error

		{{ if ne $pkType "" }}
			// PartialUpdate for {{$ident}}. Only updates fields with non-zero values using gorm.DB.Updates(). Returns the updated {{$ident}}
			PartialUpdate(id {{$pkType}}, {{$ident}} {{.ModelPkgName}}.{{.Model}}, options ...*Options)  (*{{.ModelPkgName}}.{{.Model}}, error)

			// PartialUpdateWithMap for {{$ident}}. Only updates fields with non-zero values using gorm.DB.Updates(). Returns the updated {{$ident}}
			PartialUpdateWithMap(id {{$pkType}}, data map[string]any, options ...*Options) (*{{.ModelPkgName}}.{{.Model}}, error)
		{{ end }}

		{{ if ne $pkType "" }}
			// Permanently Delete {{$ident}} from the database by primary key
			Delete(id {{$pkType}}) error
		{{ end }}

		// Permanently Delete {{$ident}} from the database matching conditions.
		DeleteWhere(value string, conds ...any) error

		// Begin returns a new instance of {{$ident}}Service that runs all queries in a transaction.
		// Call Rollback() to undo changes and Commit() to Commit the changes.
		Begin(opts ...*sql.TxOptions)({{$ident}}Service, error)

		// Commit all transactions run with the service.
		Commit() error

		// Rollback transaction.
		Rollback() error
	{{ end }}

	{{ if ne $pkType "" }}
		// Get a single {{$ident}} by id (primary key)
		Get(id {{$pkType}}, options ...*Options) (*{{.ModelPkgName}}.{{.Model}}, error)
	{{ end }}

	// Retrieves all {{$ident}}s from the database
	GetAll(options ...*Options) (results []*{{.ModelPkgName}}.{{.Model}}, err error)

	// Count returns the number of records matching the query
	Count(options ...*Options) (int64, error)

	// Find the first record matching condition specified by query & args
	FindOne(options ...*Options) (*{{.ModelPkgName}}.{{.Model}}, error)

	// Find all records matching condition specified by query & args
	FindMany(options ...*Options) (results []*{{.ModelPkgName}}.{{.Model}}, err error)

	// GetPaginated retrieves a paginated list of {{$ident}}s
	GetPaginated(page int, pageSize int, options ...*Options) (*PaginatedResults[*{{.ModelPkgName}}.{{.Model}}], error)

	// Override preload
	PreloadAll(preload bool) {{$ident}}Service

	// Preload overrides the default preloads
	Preload(query string, args ...any) {{$ident}}Service
}

// Implementation for {{$ident}}Service interface
type {{$ident}}Repo struct {
	DB *gorm.DB

	preloads []string
	preloadAll bool
}


// PreloadAll sets preloadAll to true or false
func (repo *{{$ident}}Repo) PreloadAll(preload bool) {{$ident}}Service {
	repo.preloadAll = preload
	return repo
}

// Preload sets the preloads for the service.
// This is only applied to a copy of the service. The original service is not modified.
func (repo {{$ident}}Repo) Preload(query string, args ...any) {{$ident}}Service {
	repo.preloadAll = false
	repo.DB = repo.DB.Preload(query, args...)
	return &repo
}

// Returns a {{$ident}} service that accesses the gorm.DB
// instance through dependancy injection
func new{{.Model}}Service(db *gorm.DB) {{$ident}}Service {
	return &{{$ident}}Repo{
		DB: db,
		preloads: []string{
			{{range $preloadStmt := .Preloads -}}
				"{{$preloadStmt}}",
			{{end -}}
		},
		preloadAll: {{.PreloadAll}},
	}
}

{{ if not .PkgReadOnly }}
// Create new {{$ident}}
func (repo *{{$ident}}Repo) CreateMany({{$ident}}s *[]{{.ModelPkgName}}.{{.Model}}, options ...*Options) error {
	if err := repo.DB.Omit({{ join .OmitFields ","}}).Create({{$ident}}s).Error; err != nil{
		return err
	}

	// Refetch to load associations if any
	for i, record := range *{{$ident}}s{
		tmpRecord, err := repo.Get(record.ID, options...)
		if err != nil {
			return  err
		}
		record = *tmpRecord
		(*{{$ident}}s)[i]=record
	}
	return nil
}

// Create new {{$ident}}
func (repo *{{$ident}}Repo) Create({{$ident}} *{{.ModelPkgName}}.{{.Model}}, options ...*Options) error {
	if err := repo.DB.Omit({{ join .OmitFields ","}}).Create({{$ident}}).Error; err != nil{
		return err
	}

	// Refetch to load associations if any
	tmpRecord, err := repo.Get({{$ident}}.ID, options...)
	if err != nil {
		return  err
	}

	*{{$ident}}=*tmpRecord

	return nil
}

{{ if ne $pkType "" }}
	// Update {{$ident}} with all the fields. Uses gorm.DB.Save()
	func (repo *{{$ident}}Repo) Update(id {{$pkType}}, {{$ident}} *{{.ModelPkgName}}.{{.Model}}, options...*Options)  (*{{.ModelPkgName}}.{{.Model}}, error) {
		// Make sure the ID is set on object to use Save(), otherwise you get unique constraint error.
		{{$ident}}.ID = id
		if err := repo.DB.Omit({{ join .OmitFields ","}}).Save({{$ident}}).Error; err != nil {
			return nil, err
		}

		tmp, err := repo.Get(id, options...)
		return tmp, err
	}
{{ end }}

// Update a single column. Gorm hooks will be fired because it uses Update() method.
func (repo *{{$ident}}Repo) UpdateColumn(columnName string, value any, query string, args ...any) error{
	return repo.DB.Model(&{{.ModelPkgName}}.{{.Model}}{}).Where(query, args...).Update(columnName, value).Error;	
}

{{ if ne $pkType "" }}
	// PartialUpdate for {{$ident}}. Only updates fields with no zero values. Returns the updated {{$ident}}
	func (repo *{{$ident}}Repo) PartialUpdate(id {{$pkType}}, {{$ident}} {{.ModelPkgName}}.{{.Model}}, options...*Options)  (*{{.ModelPkgName}}.{{.Model}}, error) {
		if err := repo.DB.Omit({{ join .OmitFields ","}}).Where("id=?", id).Model(&{{.ModelPkgName}}.{{.Model}}{}).Updates({{$ident}}).Error; err != nil {
			return nil, err
		}

		var updated{{$ident}} = new({{.ModelPkgName}}.{{.Model}})
		db := repo.DB

		if repo.preloadAll {
			for _, preload := range repo.preloads {
				db = db.Preload(preload)
			}
		}

		db = applyOptions(db, options...)
		if err := db.First(updated{{$ident}}, id).Error; err != nil {
			return nil, err
		}
		return updated{{$ident}}, nil
	}

	// PartialUpdateWithMap for {{$ident}}. Only updates fields with no zero values. Returns the updated {{$ident}}
	func (repo *{{$ident}}Repo) PartialUpdateWithMap(id {{$pkType}}, data map[string]any, options...*Options)  (*{{.ModelPkgName}}.{{.Model}}, error) {
		if err := repo.DB.Omit({{ join .OmitFields ","}}).Where("id=?", id).Model(&{{.ModelPkgName}}.{{.Model}}{}).Updates(data).Error; err != nil {
			return nil, err
		}

		var updated{{$ident}} = new({{.ModelPkgName}}.{{.Model}})
		db := repo.DB

		if repo.preloadAll {
			for _, preload := range repo.preloads {
				db = db.Preload(preload)
			}
		}

		db = applyOptions(db, options...)
		if err := db.First(updated{{$ident}}, id).Error; err != nil {
			return nil, err
		}
		return updated{{$ident}}, nil
	}
{{ end }}

{{ if ne $pkType "" }}
	// Permanently Delete {{$ident}} from the database by id
	func (repo *{{$ident}}Repo) Delete(id {{$pkType}}) error {
		if err := repo.DB.Unscoped().Delete(&{{.ModelPkgName}}.{{.Model}}{}, id).Error; err != nil {
			return err
		}
		return nil
	}
{{ end }}

// Permanently Delete {{$ident}} from the database matching conditions
func (repo *{{$ident}}Repo) DeleteWhere(value string, conds ...any) error {
	if err :=  repo.DB.Unscoped().Delete(&{{.ModelPkgName}}.{{.Model}}{}, value, conds).Error; err != nil {
		return err
	}
	return nil
}


// Begin returns a new instance of {{$ident}}Service that runs all queries in a transaction.
// Call Rollback() to undo changes and Commit() to Commit the changes.
func (repo *{{$ident}}Repo) Begin(opts ...*sql.TxOptions)({{$ident}}Service, error){
	tx := repo.DB.Begin(opts...)
	if tx.Error != nil{
		return nil, tx.Error
	}
	return new{{.Model}}Service(tx), nil
}

// Commit all transactions run with the service. Must have called .Begin() before.
func (repo *{{$ident}}Repo) Commit() error{
	return repo.DB.Commit().Error
}

// Rollback transaction on error.
func (repo *{{$ident}}Repo) Rollback() error{
	return repo.DB.Rollback().Error
}

{{ end }}

{{ if ne $pkType "" }}
// Make sure struct has an ID field as PK.
// Else skip this.
// Get a single {{$ident}} by id primary key
// Warning: Do not pass Where() option in options when using id, you will get unexpected results.
// (unless that's what you want!)
func (repo *{{$ident}}Repo) Get(id {{$pkType}}, options ...*Options) (*{{.ModelPkgName}}.{{.Model}}, error) {
	var {{$ident}} {{.ModelPkgName}}.{{.Model}}
	db := repo.DB

	if repo.preloadAll {
		for _, preload := range repo.preloads {
			db = db.Preload(preload)
		}
	}

	db = applyOptions(db, options...)
	if err := db.First(&{{$ident}}, id).Error; err != nil {
		return nil, err
	}
	return &{{$ident}}, nil
}
{{ end }}

// GetAll retries all {{$ident}}s
func (repo *{{$ident}}Repo) GetAll(options ...*Options) (results []*{{.ModelPkgName}}.{{.Model}}, err error) {
	db := repo.DB

	if repo.preloadAll {
		for _, preload := range repo.preloads {
			db = db.Preload(preload)
		}
	}

	db = applyOptions(db, options...)

	err = db.Find(&results).Error

	if err != nil {
		return nil, err
	}

	return
}

// Count returns the number of records matching the query
func (repo *{{$ident}}Repo) Count(options ...*Options) (int64, error) {
	var count int64
	db := repo.DB
	db = applyOptions(db, options...)
	if err := db.Model(&{{.ModelPkgName}}.{{.Model}}{}).Count(&count).Error; err != nil {
		return 0, err
	}
	return count, nil
}

// GetPaginated retrieves a paginated list of users
func (repo *{{$ident}}Repo) GetPaginated(page int, pageSize int, options ...*Options) (
	*PaginatedResults[*{{.ModelPkgName}}.{{.Model}}], error) {

	var results []*{{.ModelPkgName}}.{{.Model}}

	// Page must be >= 1
	if page < 1 {
		page = 1
	}

	// Calculate offset and limit
	offset := (page - 1) * pageSize

	// Query the database
	db := repo.DB

	if repo.preloadAll {
		for _, preload := range repo.preloads {
			db = db.Preload(preload)
		}
	}

	db = applyOptions(db, options...)

	// Retrieve total count of records after applying options
	var totalCount int64
	if err := db.Model(&{{.ModelPkgName}}.{{.Model}}{}).Count(&totalCount).Error; err != nil {
		return nil, err
	}

	if err := db.Offset(offset).Limit(pageSize).Find(&results).Error; err != nil {
		return nil, err
	}

	paginatedResults := &PaginatedResults[*{{.ModelPkgName}}.{{.Model}}]{
		Page:     page,
		PageSize: pageSize,
		HasNext:  int64(page*pageSize) < totalCount,
		HasPrev:  page > 1,
		Results:  results,
		Count:      totalCount,
		TotalPages: int64(math.Ceil(float64(totalCount) / float64(pageSize))),
	}

	return paginatedResults, nil
}



func (repo *{{$ident}}Repo) FindOne(options ...*Options) (*{{.ModelPkgName}}.{{.Model}}, error){
	var {{$ident}} {{.ModelPkgName}}.{{.Model}}
	db := repo.DB

	if repo.preloadAll {
		for _, preload := range repo.preloads {
			db = db.Preload(preload)
		}
	}

	db = applyOptions(db, options...)
	if err := db.First(&{{$ident}}).Error; err != nil {
		return nil, err
	}
	return &{{$ident}}, nil
}

func (repo *{{$ident}}Repo) FindMany(options ...*Options) (results []*{{.ModelPkgName}}.{{.Model}}, err error){
	db := repo.DB
	
	if repo.preloadAll {
		for _, preload := range repo.preloads {
			db = db.Preload(preload)
		}
	}
	
	db = applyOptions(db, options...)

	var tmpResults []{{.ModelPkgName}}.{{.Model}}
	err = db.Find(&tmpResults).Error

	if err != nil{
		return nil, err
	}

	results = make([]*{{.ModelPkgName}}.{{.Model}}, len(tmpResults))
	for i := range tmpResults {
		results[i] = &tmpResults[i]
	}
	
	return
}

{{ end }}


