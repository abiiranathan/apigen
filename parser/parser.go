package parser

import (
	"bytes"
	_ "embed"
	"fmt"
	"go/ast"
	"go/format"
	"io"
	"log"
	"slices"
	"strconv"
	"strings"
	"text/template"

	"github.com/abiiranathan/apigen/config"
	"github.com/iancoleman/strcase"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"golang.org/x/tools/go/packages"
)

//go:embed services.gotmpl
var serviceTemplate []byte

var enCaser = cases.Title(language.English)

const skipTag = "apigen:skip"

// Field contains meta-data for each struct field.
type Field struct {
	Name     string // Field Exact name
	Type     string // Full data type for the field
	BaseType string // Base type stripped of [] or pointers
	Tag      string // Unmodified struct tag.
	Preload  bool   // Whether this is a foreignKey or many2many field to preload.
	Parent   string // Parent struct Name
}

// StructMeta contains metadata about the struct generated by the go/ast.
type StructMeta struct {
	Name    string  // Model name e.g User
	PKType  string  // PKType e.g int, int64 etc
	Fields  []Field // Fields for struct fields that are builtin(only)
	Package string  // Package name e.g "github.com/username/module/models"
	Skip    bool    // Skip generating service for this struct
}

// Helper function to properly handle ast.Expr
func formatSelectorExpr(expr ast.Expr) string {
	switch x := expr.(type) {
	case *ast.Ident:
		return x.Name
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", formatSelectorExpr(x.X), x.Sel.Name)
	default:
		return ""
	}
}

// Helper function to properly forma *ast.ArrayType.
func formatArrayType(typ *ast.ArrayType) string {
	switch elemType := typ.Elt.(type) {
	case *ast.Ident:
		return elemType.Name
	case *ast.SelectorExpr:
		return formatSelectorExpr(elemType)
	case *ast.ArrayType:
		return "[]" + formatArrayType(elemType)
	default:
		return ""
	}
}

// Given *ast.ArrayType, this function returns the length of the array or 0
// if arrayType is nil or arrayType.Len == nil.
func getArrayLen(arrayType *ast.ArrayType) int {
	if arrayType == nil || arrayType.Len == nil {
		return 0
	}

	if basicLit, ok := arrayType.Len.(*ast.BasicLit); ok {
		if intValue, err := strconv.Atoi(basicLit.Value); err == nil {
			return intValue
		}
	}
	return 0
}

// Parse structs in package pkg and return Struct metadata about them.
func Parse(modelPkgs []string) []StructMeta {
	structSlice := []StructMeta{}
	cfg := &packages.Config{Mode: packages.NeedSyntax | packages.NeedTypes}

	var pkgs []*packages.Package
	for _, pkg := range modelPkgs {
		parsedPkgs, err := packages.Load(cfg, pkg)
		if err != nil {
			panic(err)
		}
		pkgs = append(pkgs, parsedPkgs...)
	}

	for _, pkg := range pkgs {
		for _, file := range pkg.Syntax {
			ast.Inspect(file, func(node ast.Node) bool {
				if t, ok := node.(*ast.TypeSpec); ok {
					if stype, ok := t.Type.(*ast.StructType); ok {
						meta := StructMeta{
							Name:    t.Name.Name,
							Package: pkg.String(),
						}

						// Check if struct should be skipped by reading for doc comments
						if t.Doc != nil {
							for _, comment := range t.Doc.List {
								if strings.Contains(comment.Text, skipTag) {
									meta.Skip = true
									log.Println("Skipping struct:", meta.Name)
								}
							}
						}

						for _, field := range stype.Fields.List {
							var tagValue string
							if field.Tag != nil {
								tagValue = field.Tag.Value
							}

							// Check if it's a foreignKey or many to many based on tag
							// foreignKey or many2many (GORM)
							isFK := strings.Contains(tagValue, "foreignKey")
							isManyToMany := strings.Contains(tagValue, "many2many")
							Preload := isFK || isManyToMany

							switch typ := field.Type.(type) {
							case *ast.Ident:
								for _, name := range field.Names {
									if name.Name == "ID" {
										meta.PKType = typ.Name
									}
									meta.Fields = append(meta.Fields,
										Field{
											Name:     name.Name,
											Parent:   meta.Name,
											Tag:      tagValue,
											Type:     typ.Name,
											BaseType: typ.Name,
											Preload:  Preload,
										})
								}
							case *ast.SelectorExpr:
								fieldType := formatSelectorExpr(typ)
								identName := fieldType
								if _, ok := field.Type.(*ast.StarExpr); ok {
									fieldType = "*" + fieldType
								}

								for _, name := range field.Names {
									meta.Fields = append(meta.Fields,
										Field{
											Name:     name.Name,
											Parent:   meta.Name,
											Tag:      tagValue,
											Type:     fieldType,
											BaseType: identName,
											Preload:  Preload,
										})
								}
							case *ast.ArrayType:
								fieldType := formatArrayType(typ)

								arrLen := getArrayLen(typ)
								var arrType string
								if arrLen == 0 {
									arrType = "[]" + fieldType
								} else {
									arrType = "[" + strconv.Itoa(arrLen) + "]" + fieldType
								}
								if _, ok := field.Type.(*ast.StarExpr); ok {
									arrType = "*" + arrType
								}

								for _, name := range field.Names {
									meta.Fields = append(meta.Fields,
										Field{
											Name:     name.Name,
											Parent:   meta.Name,
											Tag:      tagValue,
											Type:     arrType,
											BaseType: fieldType,
											Preload:  Preload,
										})
								}
							case *ast.StarExpr:
								switch t := typ.X.(type) {
								case *ast.Ident:
									for _, name := range field.Names {
										meta.Fields = append(meta.Fields,
											Field{
												Name:     name.Name,
												Parent:   meta.Name,
												Tag:      tagValue,
												Type:     "*" + t.Name,
												BaseType: t.Name,
												Preload:  Preload,
											})
									}
								case *ast.SelectorExpr:
									identName := formatSelectorExpr(t)
									fieldType := identName

									if _, ok := t.X.(*ast.StarExpr); ok {
										fieldType = "*" + fieldType
									}

									for _, name := range field.Names {
										meta.Fields = append(meta.Fields,
											Field{
												Name:     name.Name,
												BaseType: identName,
												Parent:   meta.Name,
												Tag:      tagValue,
												Type:     fieldType,
												Preload:  Preload,
											})
									}
								case *ast.ArrayType:
									if ident, ok := t.Elt.(*ast.Ident); ok {
										arrLen := getArrayLen(t)
										var arrType string
										if arrLen == 0 {
											arrType = "*[]" + ident.Name
										} else {
											arrType = "*[" + strconv.Itoa(arrLen) + "]" + ident.Name
										}

										for _, name := range field.Names {
											meta.Fields = append(meta.Fields,
												Field{
													Name:     name.Name,
													BaseType: ident.Name,
													Parent:   meta.Name,
													Tag:      tagValue,
													Type:     arrType,
													Preload:  Preload,
												})
										}
									}
								default:
								}
							default:
							}
						}
						structSlice = append(structSlice, meta)
					}
				}
				return true // Continue traversing the AST
			})
		}
	}
	return structSlice
}

// Create a StructMeta map from slice.
func Map(data []StructMeta) (m map[string]StructMeta) {
	m = make(map[string]StructMeta)
	for _, row := range data {
		m[row.Name] = row
	}
	return m
}

type tmplData struct {
	PkgName      string     // Package name for the generated service.
	ModelPkg     string     // Absolute name of package e.g "github.com/abiiranathan/todos/models"
	ModelPkgs    []string   // Absolute names of all package e.g ["github.com/abiiranathan/todos/models"]
	ModelPkgName string     // Name of package e.g "models"
	ModelObj     StructMeta // The model metadata object
	Model        string     // The struct name e.g "User"
	OmitFields   []string   // ForeignKey fields to Omit during Update
	Preloads     []string   // Stores fields to preload

	DefaultAllocSize uint // Default size for slices

	PreloadAll        bool // Preload all the relations
	PkgReadOnly       bool // For SQL Views
	WritePKGDecl      bool
	SkipService       bool // Whether to skip creating this service
	PreallocateSlices bool // Preallocate slices
}

func packageReadOnly(cfg *config.Config, pkg string) bool {
	return slices.Contains(cfg.Models.ReadOnly, pkg)
}

// Generate services for models in pkg.
// structs represents the data structures for creating the services.
//
// If models in skipServices are ignored.
func generateGORMServices(structs []StructMeta, cfg *config.Config) ([]byte, error) {
	preloads := GetPreloadMap(structs, cfg.PreloadDepth)
	buf := new(bytes.Buffer)
	modelNames := make([]string, 0, len(structs))

	for index, st := range structs {
		parts := strings.Split(st.Package, "/")
		modelPkgName := parts[len(parts)-1]

		// Avoid duplicate services
		if slices.Contains(modelNames, st.Name) {
			continue
		}

		modelNames = append(modelNames, st.Name)
		preloadFields := preloads[st.Name]

		omitFields := []string{}
		for _, f := range preloadFields {
			var prefix = f
			if strings.Contains(f, ".") {
				prefix = strings.Split(f, ".")[0]
			}

			if !slices.Contains(omitFields, prefix) {
				omitFields = append(omitFields, prefix)
			}

		}

		data := tmplData{
			PreloadAll:   cfg.PreloadAll,
			PkgName:      cfg.Output.ServiceName,
			ModelPkg:     st.Package,
			ModelPkgs:    cfg.Models.Pkgs,
			ModelPkgName: modelPkgName,
			PkgReadOnly:  packageReadOnly(cfg, st.Package),
			ModelObj:     st,
			Model:        st.Name,
			WritePKGDecl: index == 0,
			Preloads:     preloadFields,
			OmitFields:   omitFields,
			SkipService:  slices.Contains(cfg.Models.Skip, st.Name),
		}
		err := parseTemplate(buf, data)
		if err != nil {
			return nil, err
		}
	}

	// Execute template for main service
	tmpl, err := template.New("mainSVC").Funcs(template.FuncMap{
		"ToLower": strings.ToLower,
		"ToCamelCase": func(s string) string {
			return strcase.ToCamel(enCaser.String(s))
		},
	}).Parse(mainSVCTmpl)
	if err != nil {
		return nil, err
	}

	services := make([]string, 0, len(modelNames))
	for _, m := range modelNames {
		if slices.Contains(services, m) {
			continue
		}

		if !slices.Contains(cfg.Models.Skip, m) {
			services = append(services, m)
		}
	}

	if err := tmpl.Execute(buf, services); err != nil {
		return nil, err
	}

	// fmt.Println(buf.String())
	// Format source
	b, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error format source file: %w, source: %s", err, b)
	}
	return b, nil
}

// Passes data to the string template that is executed into w.
func parseTemplate(w io.Writer, data tmplData) error {
	tmpl, err := template.New("tmpl").Funcs(template.FuncMap{
		"ToLower": strings.ToLower,
		"ToCamelCase": func(s string) string {
			return strcase.ToCamel(enCaser.String(s))
		},
		"join": func(s []string, _ string) string {
			quotedSlice := make([]string, len(s))
			for i, item := range s {
				quotedSlice[i] = fmt.Sprintf("\"%s\"", item)
			}
			return strings.Join(quotedSlice, ", ")
		},
	}).Parse(string(serviceTemplate))

	if err != nil {
		return fmt.Errorf("error parsing template: %w", err)
	}

	if err := tmpl.Execute(w, data); err != nil {
		return fmt.Errorf("error executing template: %w", err)
	}

	return nil
}

var mainSVCTmpl = `
// Service embeds all generated services
type Service struct {
	{{range .}}
	{{.}}Service  {{.| ToLower }}Service
	{{- end}}

	DB *gorm.DB
}

// Add support for transactions at service level
func (s *Service) Begin() (*Service, error){
	tx := s.DB.Begin()
	if tx.Error != nil {
		return nil, tx.Error
	}
	return NewService(tx), nil
}

// Commit all transactions
func (s *Service) Commit() error {
	return s.DB.Commit().Error
}

// Rollback all transactions
func (s *Service) Rollback() error {
	return s.DB.Rollback().Error
}

// Returns a new Service that embeds all the generated services.
func NewService(db *gorm.DB) *Service {
	return &Service{
		{{- range .}}
		{{.}}Service: new{{.}}Service(db),
		{{- end}}
		DB: db,
	}
}

`
