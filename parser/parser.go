package parser

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"io"
	"strconv"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"golang.org/x/tools/go/packages"
)

var enCaser = cases.Title(language.English)

// Field contains meta-data for each struct field.
type Field struct {
	Name     string // Field Exact name
	Type     string // Full data type for the field
	BaseType string // Base type stripped of [] or pointers
	Tag      string // Unmodified struct tag.
	Preload  bool   // Whether this is a foreignKey or many2many field to preload.
	Parent   string // Parent struct Name
}

// StructMeta contains metadata about the struct generated by the go/ast.
type StructMeta struct {
	Name   string  // Model name e.g User
	PKType string  // PKType e.g int, int64 etc
	Fields []Field // Fields for struct fields that are builtin(only)
}

// Helper function to properly handle ast.Expr
func formatSelectorExpr(expr ast.Expr) string {
	switch x := expr.(type) {
	case *ast.Ident:
		return x.Name
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", formatSelectorExpr(x.X), x.Sel.Name)
	default:
		return ""
	}
}

// Helper function to properly forma *ast.ArrayType.
func formatArrayType(typ *ast.ArrayType) string {
	switch elemType := typ.Elt.(type) {
	case *ast.Ident:
		return elemType.Name
	case *ast.SelectorExpr:
		return formatSelectorExpr(elemType)
	case *ast.ArrayType:
		return "[]" + formatArrayType(elemType)
	default:
		return ""
	}
}

// Given *ast.ArrayType, this function returns the length of the array or 0
// if arrayType is nil or arrayType.Len == nil.
func getArrayLen(arrayType *ast.ArrayType) int {
	if arrayType == nil || arrayType.Len == nil {
		return 0
	}

	if basicLit, ok := arrayType.Len.(*ast.BasicLit); ok {
		if intValue, err := strconv.Atoi(basicLit.Value); err == nil {
			return intValue
		}
	}
	return 0
}

// Parse structs in package pkg and return Struct metadata about them.
func Parse(pkg string) []StructMeta {
	structSlice := []StructMeta{}
	cfg := &packages.Config{Mode: packages.NeedSyntax | packages.NeedTypes}
	pkgs, err := packages.Load(cfg, pkg)
	if err != nil {
		panic(err)
	}

	for _, pkg := range pkgs {
		for _, file := range pkg.Syntax {
			ast.Inspect(file, func(node ast.Node) bool {
				if t, ok := node.(*ast.TypeSpec); ok {
					if stype, ok := t.Type.(*ast.StructType); ok {
						meta := StructMeta{
							Name: t.Name.Name,
						}

						for _, field := range stype.Fields.List {
							var tagValue string
							if field.Tag != nil {
								tagValue = field.Tag.Value
							}

							// Check if it's a foreignKey or many to many based on tag
							// foreignKey or many2many (GORM)
							isFK := strings.Contains(tagValue, "foreignKey")
							isManyToMany := strings.Contains(tagValue, "many2many")
							Preload := isFK || isManyToMany

							switch typ := field.Type.(type) {
							case *ast.Ident:
								for _, name := range field.Names {
									if name.Name == "ID" {
										meta.PKType = typ.Name
									}
									meta.Fields = append(meta.Fields,
										Field{
											Name:     name.Name,
											Parent:   meta.Name,
											Tag:      tagValue,
											Type:     typ.Name,
											BaseType: typ.Name,
											Preload:  Preload,
										})
								}
							case *ast.SelectorExpr:
								fieldType := formatSelectorExpr(typ)
								identName := fieldType
								if _, ok := field.Type.(*ast.StarExpr); ok {
									fieldType = "*" + fieldType
								}

								for _, name := range field.Names {
									meta.Fields = append(meta.Fields,
										Field{
											Name:     name.Name,
											Parent:   meta.Name,
											Tag:      tagValue,
											Type:     fieldType,
											BaseType: identName,
											Preload:  Preload,
										})
								}
							case *ast.ArrayType:
								fieldType := formatArrayType(typ)

								arrLen := getArrayLen(typ)
								var arrType string
								if arrLen == 0 {
									arrType = "[]" + fieldType
								} else {
									arrType = "[" + strconv.Itoa(arrLen) + "]" + fieldType
								}
								if _, ok := field.Type.(*ast.StarExpr); ok {
									arrType = "*" + arrType
								}

								for _, name := range field.Names {
									meta.Fields = append(meta.Fields,
										Field{
											Name:     name.Name,
											Parent:   meta.Name,
											Tag:      tagValue,
											Type:     arrType,
											BaseType: fieldType,
											Preload:  Preload,
										})
								}
							case *ast.StarExpr:
								switch t := typ.X.(type) {
								case *ast.Ident:
									for _, name := range field.Names {
										meta.Fields = append(meta.Fields,
											Field{
												Name:     name.Name,
												Parent:   meta.Name,
												Tag:      tagValue,
												Type:     "*" + t.Name,
												BaseType: t.Name,
												Preload:  Preload,
											})
									}
								case *ast.SelectorExpr:
									identName := formatSelectorExpr(t)
									fieldType := identName

									if _, ok := t.X.(*ast.StarExpr); ok {
										fieldType = "*" + fieldType
									}

									for _, name := range field.Names {
										meta.Fields = append(meta.Fields,
											Field{
												Name:     name.Name,
												BaseType: identName,
												Parent:   meta.Name,
												Tag:      tagValue,
												Type:     fieldType,
												Preload:  Preload,
											})
									}
								case *ast.ArrayType:
									if ident, ok := t.Elt.(*ast.Ident); ok {
										arrLen := getArrayLen(t)
										var arrType string
										if arrLen == 0 {
											arrType = "*[]" + ident.Name
										} else {
											arrType = "*[" + strconv.Itoa(arrLen) + "]" + ident.Name
										}

										for _, name := range field.Names {
											meta.Fields = append(meta.Fields,
												Field{
													Name:     name.Name,
													BaseType: ident.Name,
													Parent:   meta.Name,
													Tag:      tagValue,
													Type:     arrType,
													Preload:  Preload,
												})
										}
									}
								default:
								}
							default:
							}
						}
						structSlice = append(structSlice, meta)
					}
				}
				return true
			})
		}
	}
	return structSlice
}

// Create a StructMeta map from slice.
func Map(data []StructMeta) (m map[string]StructMeta) {
	m = make(map[string]StructMeta)
	for _, row := range data {
		m[row.Name] = row
	}
	return m
}

type tmplData struct {
	PkgName      string     // Package name for the generated service.
	ModelPkg     string     // Absolute name of package e.g "github.com/abiiranathan/todos/models"
	ModelPkgName string     // Name of package e.g "models"
	ModelObj     StructMeta // The model metadata object
	Model        string     // The struct name e.g "User"
	WritePKGDecl bool
	OmitFields   []string // ForeignKey fields to Omit during Update
	Preloads     []string // Stores fields to preload
	SkipService  bool     // Whether to skip creating this service
}

func sliceContains(slice []string, s string) bool {
	for _, item := range slice {
		if item == s {
			return true
		}
	}
	return false
}

// Generate services for models in pkg.
// structs represents the data structures for creating the services.
//
// If models in skipServices are ignored.
func generateGORMServices(outPkg string, modelPkg string,
	structs []StructMeta, skipServices ...string) ([]byte, error) {

	preloads := GetPreloadMap(structs)
	parts := strings.Split(modelPkg, "/")
	modelPkgName := parts[len(parts)-1]
	buf := new(bytes.Buffer)

	modelNames := make([]string, len(structs))
	for index, st := range structs {
		modelNames[index] = st.Name
		preloadFields := preloads[st.Name]

		omitFields := []string{}
		for _, f := range preloadFields {
			var prefix string = f
			if strings.Contains(f, ".") {
				prefix = strings.Split(f, ".")[0]
			}

			if !sliceContains(omitFields, prefix) {
				omitFields = append(omitFields, prefix)
			}

		}

		data := tmplData{
			PkgName:      outPkg,
			ModelPkg:     modelPkg,
			ModelPkgName: modelPkgName,
			ModelObj:     st,
			Model:        st.Name,
			WritePKGDecl: index == 0,
			Preloads:     preloadFields,
			OmitFields:   omitFields,
			SkipService:  sliceContains(skipServices, st.Name),
		}
		err := parseTemplate(buf, data)
		if err != nil {
			return nil, err
		}
	}

	// Execute template for main service
	tmpl, err := template.New("mainSVC").Funcs(template.FuncMap{
		"ToLower": strings.ToLower,
		"ToCamelCase": func(s string) string {
			return strcase.ToCamel(enCaser.String(s))
		},
	}).Parse(mainSVCTmpl)
	if err != nil {
		return nil, err
	}

	services := make([]string, 0, len(modelNames))
	for _, m := range modelNames {
		if !sliceContains(skipServices, m) {
			services = append(services, m)
		}
	}

	if err := tmpl.Execute(buf, services); err != nil {
		return nil, err
	}

	// fmt.Println(buf.String())
	// Format source
	b, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error format source file: %w, source: %s", err, b)
	}
	return b, nil
}

// Passes data to the string template that is executed into w.
func parseTemplate(w io.Writer, data tmplData) error {
	tmpl, err := template.New("tmpl").Funcs(template.FuncMap{
		"ToLower": strings.ToLower,
		"ToCamelCase": func(s string) string {
			return strcase.ToCamel(enCaser.String(s))
		},
		"join": func(s []string, sep string) string {
			quotedSlice := make([]string, len(s))
			for i, item := range s {
				quotedSlice[i] = fmt.Sprintf("\"%s\"", item)
			}
			return strings.Join(quotedSlice, ", ")
		},
	}).Parse(serviceTemplate)

	if err != nil {
		return fmt.Errorf("error parsing template: %w", err)
	}

	if err := tmpl.Execute(w, data); err != nil {
		return fmt.Errorf("error executing template: %w", err)
	}

	return nil
}

var serviceTemplate = `{{if .WritePKGDecl}}
// Code generated by "apigen"; DO NOT EDIT.

package {{.PkgName}}

import (
	"{{.ModelPkg}}"
	"gorm.io/gorm"
	"math"
)

/*
Options to pass to GORM.
Preferred order of option: Select,Group, Where, Or, Joins, Preload, Order, Limit, Offset, etc
For example:

	Select("column1, column2").
    Where("column3 = ?", value).
    Joins("JOIN t1 ON t1.id = t.id").
    Order("column ASC").
    Limit(10).
    Offset(0).
    Find(&results)
*/
type Option func(db *gorm.DB)*gorm.DB


/*
Where add conditions
See the docs for details on the various formats that where clauses can take. By default, where clauses chain with AND.

	Find the first user with name john
	Where("name = ?", "john")

*/
func Where(query string, args...any) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Where(query, args...)
		return db
	}
}

/*
Preload preload associations with given conditions

	Preload("Orders", "state NOT IN (?)", "cancelled")
*/
func Preload(query string, args...any) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Preload(query, args...)
		return db
	}
}

/*
Select specify fields that you want when querying, creating, updating

Use Select when you only want a subset of the fields. 
By default, GORM will select all fields.

	Select("name", "age")
*/
func Select(columns ...string) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Select(columns)
		return db
	}
}

// Omit specify fields that you want to ignore when creating, updating and querying
func Omit(columns ...string) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Omit(columns...)
		return db
	}
}


// Order("name DESC")
func Order(order string) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Order(order)
		return db
	}
}


// Select("name, sum(age) as total"), Group("name")
func Group(group string) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Group(group)
		return db
	}
}


// Select("name, sum(age) as total"), Group("name"), Having("name = ?", "john")
func Having(query interface{}, args ...interface{}) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Having(query, args ...)
		return db
	}
}


// Limit(3) - Retrieve three users
func Limit(limit int) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Limit(limit)
		return db
	}
}


//	Offset(2) - Select the third user
func Offset(offset int) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Offset(offset)
		return db
	}
}

/*
Joins specify Joins conditions

	Joins("Account")
	Joins("JOIN emails ON emails.user_id = users.id AND emails.email = ?", "johndoe@example.org")
*/
func Joins(query string, args ...interface{}) Option{
	return func(db *gorm.DB) *gorm.DB{
		db = db.Joins(query, args...)
		return db
	}
}


func applyOptions(db *gorm.DB, options ...Option) *gorm.DB {
	for _, option := range options{
		db = option(db)
	}
	return db
}

// PaginatedResults defines options for paginated queries.
type PaginatedResults[T any] struct {
    Page     int  ` + "`json:\"page\"`" + `
    PageSize int ` + "`json:\"page_size\"`" + `
    TotalPages  int64  ` + "`json:\"total_pages\"`" + `
    Count  int64  ` + "`json:\"count\"`" + `
    HasNext  bool ` + "`json:\"has_next\"`" + `
    HasPrev  bool ` + "`json:\"has_prev\"`" + `
    Results  []T  ` + "`json:\"results\"`" + `
}

{{end}}


{{$ident:=.Model | ToLower}}
{{$pkType := .ModelObj.PKType}}

{{ if not .SkipService }}
// {{$ident}}Service interface. Defines a CRUD interface for GORM ORM.
type {{$ident}}Service interface {
	// Create new {{$ident}}
	Create({{$ident}} *{{.ModelPkgName}}.{{.Model}}, options ...Option) error

	// Create multiple {{$ident}}s
	CreateMany({{$ident}}s *[]{{.ModelPkgName}}.{{.Model}}, options ...Option) error

	// Get a single {{$ident}} by id (primary key)
	Get(id {{$pkType}}, options ...Option) ({{.ModelPkgName}}.{{.Model}}, error)

	// Retrieves all {{$ident}}s from the database
	GetAll(options ...Option) (results []{{.ModelPkgName}}.{{.Model}}, err error)

	// Find the first record matching condition specified by query &amp; args
	FindOne(options ...Option) ({{.ModelPkgName}}.{{.Model}}, error)

	// Find all records matching condition specified by query &amp; args
	FindMany(options ...Option) (results []{{.ModelPkgName}}.{{.Model}}, err error)

	// GetPaginated retrieves a paginated list of {{$ident}}s
	GetPaginated(page int, pageSize int, options ...Option) (*PaginatedResults[{{.ModelPkgName}}.{{.Model}}], error)

    // Update {{$ident}} with all the fields. Uses gorm.DB.Save()
	Update({{$ident}}Id {{$pkType}}, {{$ident}} *{{.ModelPkgName}}.{{.Model}}, options ...Option) ({{.ModelPkgName}}.{{.Model}}, error)

	// Update a single column with specified conditions
	UpdateColumn(columnName string, value any, where string, target ...any) error

	// PartialUpdate for {{$ident}}. Only updates fields with non-zero values using gorm.DB.Updates(). Returns the updated {{$ident}}
	PartialUpdate(id {{$pkType}}, {{$ident}} {{.ModelPkgName}}.{{.Model}}, options ...Option) ({{.ModelPkgName}}.{{.Model}}, error)

	// Permanently Delete {{$ident}} from the database by primary key
	Delete(id {{$pkType}}) error

	// Permanently Delete {{$ident}} from the database matching conditions.
	DeleteWhere(value string, conds ...any) error
}


// Implementation for {{$ident}}Service interface
type {{$ident}}Repo struct {
	DB *gorm.DB
}

// Returns a {{$ident}} service that accesses the gorm.DB
// instance through dependancy injection
func new{{.Model}}Service(db *gorm.DB) {{$ident}}Service {
	return &{{$ident}}Repo{DB: db}
}

// Create new {{$ident}}
func (repo *{{$ident}}Repo) CreateMany({{$ident}}s *[]{{.ModelPkgName}}.{{.Model}}, options ...Option) error {
	if err := repo.DB.Omit({{ join .OmitFields ","}}).Create({{$ident}}s).Error; err != nil{
		return err
	}

	// Refetch to load associations if any
	for i, record := range *{{$ident}}s{
		record, err := repo.Get(record.ID, options...)
		if err != nil {
			return  err
		}
		(*{{$ident}}s)[i]=record
	}
	return nil
}


// Create new {{$ident}}
func (repo *{{$ident}}Repo) Create({{$ident}} *{{.ModelPkgName}}.{{.Model}}, options ...Option) error {
	if err := repo.DB.Omit({{ join .OmitFields ","}}).Create({{$ident}}).Error; err != nil{
		return err
	}

	// Refetch to load associations if any
	record, err := repo.Get({{$ident}}.ID, options...)
	if err != nil {
		return  err
	}
	*{{$ident}}=record
	return nil
}

// Get a single {{$ident}} by id primary key
// Warning: Do not pass Where() option in options when using id, you will get unexpected results.
// (unless that's what you want!)
func (repo *{{$ident}}Repo) Get(id {{$pkType}}, options ...Option) ({{.ModelPkgName}}.{{.Model}}, error) {
	var {{$ident}} {{.ModelPkgName}}.{{.Model}}
	db := repo.DB
	{{range $preloadStmt := .Preloads -}}
    	db = db.Preload("{{$preloadStmt}}")
	{{end -}}

	db = applyOptions(db, options...)
	if err := db.First(&{{$ident}}, id).Error; err != nil {
		return {{.ModelPkgName}}.{{.Model}}{}, err
	}
	return {{$ident}}, nil
}


// Retries all {{$ident}}s
func (repo *{{$ident}}Repo) GetAll(options ...Option) (results []{{.ModelPkgName}}.{{.Model}}, err error) {
	db := repo.DB
	{{range $preloadStmt := .Preloads -}}
    	db = db.Preload("{{$preloadStmt}}")
	{{end -}}

	db = applyOptions(db, options...)
	err = db.Find(&results).Error
	return
}

// GetPaginated retrieves a paginated list of users
func (repo *{{$ident}}Repo) GetPaginated(page int, pageSize int, options ...Option) (
	*PaginatedResults[{{.ModelPkgName}}.{{.Model}}], error) {

	var results []{{.ModelPkgName}}.{{.Model}}

	// Retrieve total count of records
	var totalCount int64
	if err := repo.DB.Model(&{{.ModelPkgName}}.{{.Model}}{}).Count(&totalCount).Error; err != nil {
		return nil, err
	}

	// Page must be >= 1
	if page < 1 {
		page = 1
	}

	// Calculate offset and limit
	offset := (page - 1) * pageSize

	// Query the database
	db := repo.DB
	{{range $preloadStmt := .Preloads -}}
    	db = db.Preload("{{$preloadStmt}}")
	{{end -}}
	db = applyOptions(db, options...)

	if err := db.Offset(offset).Limit(pageSize).Find(&results).Error; err != nil{
		return nil, err
	}

	paginatedResults := &PaginatedResults[{{.ModelPkgName}}.{{.Model}}]{
		Page:     page,
		PageSize: pageSize,
		HasNext:  int64(page*pageSize) < totalCount,
		HasPrev:  page > 1,
		Results: results,
		Count: totalCount,
		TotalPages:   int64(math.Ceil(float64(totalCount) / float64(pageSize))),
	}

	return paginatedResults, nil
}


func (repo *{{$ident}}Repo) FindOne(options ...Option) ({{.ModelPkgName}}.{{.Model}}, error){
	var {{$ident}} {{.ModelPkgName}}.{{.Model}}
	db := repo.DB
	{{range $preloadStmt := .Preloads -}}
    	db = db.Preload("{{$preloadStmt}}")
	{{end -}}

	db = applyOptions(db, options...)
	if err := db.First(&{{$ident}}).Error; err != nil {
		return {{.ModelPkgName}}.{{.Model}}{}, err
	}
	return {{$ident}}, nil
}


func (repo *{{$ident}}Repo) FindMany(options ...Option) (results []{{.ModelPkgName}}.{{.Model}}, err error){
	db := repo.DB
	{{range $preloadStmt := .Preloads -}}
    	db = db.Preload("{{$preloadStmt}}")
	{{end -}}
	
	db = applyOptions(db, options...)
	err = db.Find(&results).Error
	return
}

// Update {{$ident}} with all the fields. Uses gorm.DB.Save()
func (repo *{{$ident}}Repo) Update(id {{$pkType}}, {{$ident}} *{{.ModelPkgName}}.{{.Model}}, options...Option) ({{.ModelPkgName}}.{{.Model}}, error) {
	// Make sure the ID is set on object to use Save(), otherwise you get unique constraint error.
	{{$ident}}.ID = id
	if err := repo.DB.Omit({{ join .OmitFields ","}}).Save({{$ident}}).Error; err != nil {
		return {{.ModelPkgName}}.{{.Model}}{}, err
	}
	return repo.Get(id, options...)
}

// Update a single column. Gorm hooks will be fired because it uses Update() method.
func (repo *{{$ident}}Repo) UpdateColumn(columnName string, value any, where string, target ...any) error{
	return repo.DB.Model(&{{.ModelPkgName}}.{{.Model}}{}).Where(where, target...).Update(columnName, value).Error;	
}

// PartialUpdate for {{$ident}}. Only updates fields with no zero values. Returns the updated {{$ident}}
func (repo *{{$ident}}Repo) PartialUpdate(id {{$pkType}}, {{$ident}} {{.ModelPkgName}}.{{.Model}}, options...Option) ({{.ModelPkgName}}.{{.Model}}, error) {
	if err := repo.DB.Omit({{ join .OmitFields ","}}).Where("id=?", id).Model(&{{.ModelPkgName}}.{{.Model}}{}).Updates({{$ident}}).Error; err != nil {
		return {{.ModelPkgName}}.{{.Model}}{}, err
	}

	var updated{{$ident}} {{.ModelPkgName}}.{{.Model}}
	db := repo.DB
	{{range $preloadStmt := .Preloads -}}
    	db = db.Preload("{{$preloadStmt}}")
	{{end -}}

	db = applyOptions(db, options...)
	if err := db.First(&updated{{$ident}}, id).Error; err != nil {
		return {{.ModelPkgName}}.{{.Model}}{}, err
	}
	return updated{{$ident}}, nil
}


// Permanently Delete {{$ident}} from the database by id
func (repo *{{$ident}}Repo) Delete(id {{$pkType}}) error {
	if err := repo.DB.Unscoped().Delete(&{{.ModelPkgName}}.{{.Model}}{}, id).Error; err != nil {
		return err
	}
	return nil
}

// Permanently Delete {{$ident}} from the database matching conditions
func (repo *{{$ident}}Repo) DeleteWhere(value string, conds ...any) error {
	if err :=  repo.DB.Unscoped().Delete(&{{.ModelPkgName}}.{{.Model}}{}, value, conds).Error; err != nil {
		return err
	}
	return nil
}

{{end}}
`

var mainSVCTmpl = `
// Service embeds all generated services
type Service struct {
	{{range .}}
	{{.}}Service  {{.| ToLower }}Service
	{{- end}}
}

// Returns a new Service that embeds all the generated services.
func NewService(db *gorm.DB) *Service {
	return &Service{
		{{- range .}}
		{{.}}Service: new{{.}}Service(db),
		{{- end}}
	}
}

`
